{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RESPX Mock HTTPX with awesome request patterns and response side effects. QuickStart RESPX is a simple, yet powerful , utility for mocking out the HTTPX , and HTTP Core , libraries. Start by patching HTTPX , using respx.mock , then add request routes to mock responses . import httpx import respx from httpx import Response @respx . mock def test_example (): my_route = respx . get ( \"https://foo.bar/\" ) . mock ( return_value = Response ( 204 )) response = httpx . get ( \"https://foo.bar/\" ) assert my_route . called assert response . status_code == 204 Read the User Guide for a complete walk-through. pytest + httpx For a neater pytest experience, RESPX includes a respx_mock fixture for easy HTTPX mocking, along with an optional respx marker to fine-tune the mock settings . import httpx import pytest def test_default ( respx_mock ): respx_mock . get ( \"https://foo.bar/\" ) . mock ( return_value = httpx . Response ( 204 )) response = httpx . get ( \"https://foo.bar/\" ) assert response . status_code == 204 @pytest . mark . respx ( base_url = \"https://foo.bar\" ) def test_with_marker ( respx_mock ): respx_mock . get ( \"/baz/\" ) . mock ( return_value = httpx . Response ( 204 )) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . status_code == 204 Installation Install with pip: $ pip install respx Requires Python 3.7+ and HTTPX 0.21+. See Changelog for older HTTPX compatibility.","title":"Introduction"},{"location":"#quickstart","text":"RESPX is a simple, yet powerful , utility for mocking out the HTTPX , and HTTP Core , libraries. Start by patching HTTPX , using respx.mock , then add request routes to mock responses . import httpx import respx from httpx import Response @respx . mock def test_example (): my_route = respx . get ( \"https://foo.bar/\" ) . mock ( return_value = Response ( 204 )) response = httpx . get ( \"https://foo.bar/\" ) assert my_route . called assert response . status_code == 204 Read the User Guide for a complete walk-through.","title":"QuickStart"},{"location":"#pytest-httpx","text":"For a neater pytest experience, RESPX includes a respx_mock fixture for easy HTTPX mocking, along with an optional respx marker to fine-tune the mock settings . import httpx import pytest def test_default ( respx_mock ): respx_mock . get ( \"https://foo.bar/\" ) . mock ( return_value = httpx . Response ( 204 )) response = httpx . get ( \"https://foo.bar/\" ) assert response . status_code == 204 @pytest . mark . respx ( base_url = \"https://foo.bar\" ) def test_with_marker ( respx_mock ): respx_mock . get ( \"/baz/\" ) . mock ( return_value = httpx . Response ( 204 )) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . status_code == 204","title":"pytest + httpx"},{"location":"#installation","text":"Install with pip: $ pip install respx Requires Python 3.7+ and HTTPX 0.21+. See Changelog for older HTTPX compatibility.","title":"Installation"},{"location":"api/","text":"API Reference Router Configuration Creates a mock Router instance, ready to be used as decorator/manager for activation. respx. mock (assert_all_mocked=True, assert_all_called=True, base_url=None ) Parameters: assert_all_mocked - (optional) bool - default: True Asserts that all sent and captured HTTPX requests are routed and mocked. If disabled, all non-routed requests will be auto mocked with status code 200 . assert_all_called - (optional) bool - default: True Asserts that all added and mocked routes were called when exiting context. base_url - (optional) str Base URL to match, on top of each route specific pattern and/or side effect. Returns: Router NOTE When using the default mock router respx.mock , without settings , assert_all_called is disabled . pytest Use the @pytest.mark.respx(...) marker with these parameters to configure the respx_mock pytest fixture . .route() Adds a new, optionally named , Route with given patterns and/or lookups combined, using the AND operator. respx. route ( *patterns, name=None, **lookups ) Parameters: patterns - (optional) args One or more pattern objects. lookups - (optional) kwargs One or more pattern keyword lookups , given as <pattern>__<lookup>=value . name - (optional) str Name this route. Returns: Route .get(), .post(), ... HTTP method helpers to add routes, mimicking the HTTPX Helper Functions . respx. get ( url, name=None, **lookups ) respx. options (...) respx. head (...) respx. post (...) respx. put (...) respx. patch (...) respx. delete (...) Parameters: url - (optional) str | compiled regex | tuple (httpcore) | httpx.URL Request URL to match, full or partial , turned into a URL pattern. name - (optional) str Name this route. lookups - (optional) kwargs One or more pattern keyword lookups , given as <pattern>__<lookup>=value . Returns: Route respx . get ( \"https://example.org/\" , params = { \"foo\" : \"bar\" }, ... ) .request() respx. request ( method, url, name=None, **lookups ) Parameters: method - str Request HTTP method to match. url - (optional) str | compiled regex | tuple (httpcore) | httpx.URL Request URL to match, full or partial , turned into a URL pattern. name - (optional) str Name this route. lookups - (optional) kwargs One or more pattern keyword lookups , given as <pattern>__<lookup>=value . Returns: Route respx . request ( \"GET\" , \"https://example.org/\" , params = { \"foo\" : \"bar\" }, ... ) Route .mock() Mock a route's response or side effect. route. mock ( return_value=None, side_effect=None ) Parameters: return_value - (optional) Response HTTPX Response to mock and return. side_effect - (optional) Callable | Exception | Iterable of httpx.Response/Exception Side effect to call, exception to raise or stacked responses to respond with in order. Returns: Route .return_value Setter for the HTTPX Response to return. route. return_value = Response(204) .side_effect Setter for the side effect to trigger. route. side_effect = ... See route.mock() for valid side effect types. .respond() Shortcut for creating and mocking a HTTPX Response . route. respond ( status_code=200, headers=None, content=None, text=None, html=None, json=None, stream=None ) Parameters: status_code - (optional) int - default: 200 Response status code to mock. headers - (optional) dict Response headers to mock. content - (optional) bytes | str | iterable bytes Response raw content to mock. text - (optional) str Response text content to mock, with automatic content-type header added. html - (optional) str Response HTML content to mock, with automatic content-type header added. json - (optional) str | list | dict Response JSON content to mock, with automatic content-type header added. stream - (optional) Iterable[bytes] Response stream to mock. Returns: Route .pass_through() route. pass_through ( value=True ) Parameters: value - (optional) bool - default: True Mark route to pass through, sending matched requests to real server, e.g. don't mock . Returns: Route Response NOTE This is a partial reference for how to the instantiate the HTTPX Response class, e.g. not a RESPX class. httpx. Response ( status_code, headers=None, content=None, text=None, html=None, json=None, stream=None ) Parameters: status_code - int HTTP status code. headers - (optional) dict | httpx.Headers HTTP headers. content - (optional) bytes | str | Iterable[bytes] Raw content. text - (optional) str Text content, with automatic content-type header added. html - (optional) str HTML content, with automatic content-type header added. json - (optional) str | list | dict JSON content, with automatic content-type header added. stream - (optional) Iterable[bytes] Content stream . Patterns M() Creates a reusable pattern, combining multiple arguments using the AND operator. M ( *patterns, **lookups ) Parameters: patterns - (optional) args One or more pattern objects. lookups - (optional) kwargs One or more pattern keyword lookups , given as <pattern>__<lookup>=value . Returns: Pattern import respx from respx.patterns import M pattern = M ( host = \"example.org\" ) respx . route ( pattern ) See operators for advanced usage. Method Matches request HTTP method , using eq as default lookup. Key: method Lookups: eq , in respx . route ( method = \"GET\" ) respx . route ( method__in = [ \"PUT\" , \"PATCH\" ]) Scheme Matches request URL scheme , using eq as default lookup. Key: scheme Lookups: eq , in respx . route ( scheme = \"https\" ) respx . route ( scheme__in = [ \"http\" , \"https\" ]) Host Matches request URL host , using eq as default lookup. Key: host Lookups: eq , regex , in respx . route ( host = \"example.org\" ) respx . route ( host__regex = r \"example\\.(org|com)\" ) respx . route ( host__in = [ \"example.org\" , \"example.com\" ]) Port Matches request URL port , using eq as default lookup. Key: port Lookups: eq , in respx . route ( port = 8000 ) respx . route ( port__in = [ 2375 , 2376 ]) Path Matches request URL path , using eq as default lookup. Key: path Lookups: eq , regex , startswith , in respx . route ( path = \"/api/foobar/\" ) respx . route ( path__regex = r \"^/api/(?P<slug>\\w+)/\" ) respx . route ( path__startswith = \"/api/\" ) respx . route ( path__in = [ \"/api/v1/foo/\" , \"/api/v2/foo/\" ]) Params Matches request URL query params , using contains as default lookup. Key: params Lookups: contains , eq respx . route ( params = { \"foo\" : \"bar\" , \"ham\" : \"spam\" }) respx . route ( params = [( \"foo\" , \"bar\" ), ( \"ham\" , \"spam\" )]) respx . route ( params = (( \"foo\" , \"bar\" ), ( \"ham\" , \"spam\" ))) respx . route ( params = \"foo=bar&ham=spam\" ) NOTE A request querystring with multiple parameters of the same name is treated as an ordered list when matching. ANY value Use mock.ANY as value to only match on parameter presence, e.g. respx.route(params={\"foo\": ANY}) . URL Matches request URL . When no lookup is given, url works as a shorthand pattern, combining individual request URL parts, using the AND operator. Key: url Lookups: eq , regex , startswith respx . get ( \"//example.org/foo/\" ) # == M(host=\"example.org\", path=\"/foo/\") respx . get ( url__eq = \"https://example.org:8080/foobar/?ham=spam\" ) respx . get ( url__regex = r \"https://example.org/(?P<slug>\\w+)/\" ) respx . get ( url__startswith = \"https://example.org/api/\" ) respx . get ( \"all://*.example.org/foo/\" ) Content Matches request raw content , using eq as default lookup. Key: content Lookups: eq respx . post ( \"https://example.org/\" , content = \"foobar\" ) respx . post ( \"https://example.org/\" , content = b \"foobar\" ) Data Matches request form data , using eq as default lookup. Key: data Lookups: eq respx . post ( \"https://example.org/\" , data = { \"foo\" : \"bar\" }) JSON Matches request json content, using eq as default lookup. Key: json Lookups: eq respx . post ( \"https://example.org/\" , json = { \"foo\" : \"bar\" }) The json pattern also supports path traversing, i.e. json__<path>=<value> . respx . post ( \"https://example.org/\" , json__foobar__0__ham = \"spam\" ) httpx . post ( \"https://example.org/\" , json = { \"foobar\" : [{ \"ham\" : \"spam\" }]}) Headers Matches request headers , using contains as default lookup. Key: headers Lookups: contains , eq respx . route ( headers = { \"foo\" : \"bar\" , \"ham\" : \"spam\" }) respx . route ( headers = [( \"foo\" , \"bar\" ), ( \"ham\" , \"spam\" )]) Cookies Matches request cookie header , using contains as default lookup. Key: cookies Lookups: contains , eq respx . route ( cookies = { \"foo\" : \"bar\" , \"ham\" : \"spam\" }) respx . route ( cookies = [( \"foo\" , \"bar\" ), ( \"ham\" , \"spam\" )]) Lookups eq M ( path = \"/foo/bar/\" ) M ( path__eq = \"/foo/bar/\" ) contains Case-sensitive containment test. M ( params__contains = { \"id\" : \"123\" }) in Case-sensitive within test. M ( method__in = [ \"PUT\" , \"PATCH\" ]) regex M ( path__regex = r \"^/api/(?P<slug>\\w+)/\" ) startswith Case-sensitive starts-with. M ( path__startswith = \"/api/\" ) Operators Patterns can be combined using bitwise operators, creating new patterns. AND (&) Combines two Pattern s using and operator. M ( scheme = \"http\" ) & M ( host = \"example.org\" ) OR (&) Combines two Pattern s using or operator. M ( method = \"PUT\" ) | M ( method = \"PATCH\" ) INVERT (~) Inverts a Pattern match. ~ M ( params = { \"foo\" : \"bar\" })","title":"API Reference"},{"location":"api/#api-reference","text":"","title":"API Reference"},{"location":"api/#router","text":"","title":"Router"},{"location":"api/#configuration","text":"Creates a mock Router instance, ready to be used as decorator/manager for activation. respx. mock (assert_all_mocked=True, assert_all_called=True, base_url=None ) Parameters: assert_all_mocked - (optional) bool - default: True Asserts that all sent and captured HTTPX requests are routed and mocked. If disabled, all non-routed requests will be auto mocked with status code 200 . assert_all_called - (optional) bool - default: True Asserts that all added and mocked routes were called when exiting context. base_url - (optional) str Base URL to match, on top of each route specific pattern and/or side effect. Returns: Router NOTE When using the default mock router respx.mock , without settings , assert_all_called is disabled . pytest Use the @pytest.mark.respx(...) marker with these parameters to configure the respx_mock pytest fixture .","title":"Configuration"},{"location":"api/#route","text":"Adds a new, optionally named , Route with given patterns and/or lookups combined, using the AND operator. respx. route ( *patterns, name=None, **lookups ) Parameters: patterns - (optional) args One or more pattern objects. lookups - (optional) kwargs One or more pattern keyword lookups , given as <pattern>__<lookup>=value . name - (optional) str Name this route. Returns: Route","title":".route()"},{"location":"api/#get-post","text":"HTTP method helpers to add routes, mimicking the HTTPX Helper Functions . respx. get ( url, name=None, **lookups ) respx. options (...) respx. head (...) respx. post (...) respx. put (...) respx. patch (...) respx. delete (...) Parameters: url - (optional) str | compiled regex | tuple (httpcore) | httpx.URL Request URL to match, full or partial , turned into a URL pattern. name - (optional) str Name this route. lookups - (optional) kwargs One or more pattern keyword lookups , given as <pattern>__<lookup>=value . Returns: Route respx . get ( \"https://example.org/\" , params = { \"foo\" : \"bar\" }, ... )","title":".get(), .post(), ..."},{"location":"api/#request","text":"respx. request ( method, url, name=None, **lookups ) Parameters: method - str Request HTTP method to match. url - (optional) str | compiled regex | tuple (httpcore) | httpx.URL Request URL to match, full or partial , turned into a URL pattern. name - (optional) str Name this route. lookups - (optional) kwargs One or more pattern keyword lookups , given as <pattern>__<lookup>=value . Returns: Route respx . request ( \"GET\" , \"https://example.org/\" , params = { \"foo\" : \"bar\" }, ... )","title":".request()"},{"location":"api/#route_1","text":"","title":"Route"},{"location":"api/#mock","text":"Mock a route's response or side effect. route. mock ( return_value=None, side_effect=None ) Parameters: return_value - (optional) Response HTTPX Response to mock and return. side_effect - (optional) Callable | Exception | Iterable of httpx.Response/Exception Side effect to call, exception to raise or stacked responses to respond with in order. Returns: Route","title":".mock()"},{"location":"api/#return_value","text":"Setter for the HTTPX Response to return. route. return_value = Response(204)","title":".return_value"},{"location":"api/#side_effect","text":"Setter for the side effect to trigger. route. side_effect = ... See route.mock() for valid side effect types.","title":".side_effect"},{"location":"api/#respond","text":"Shortcut for creating and mocking a HTTPX Response . route. respond ( status_code=200, headers=None, content=None, text=None, html=None, json=None, stream=None ) Parameters: status_code - (optional) int - default: 200 Response status code to mock. headers - (optional) dict Response headers to mock. content - (optional) bytes | str | iterable bytes Response raw content to mock. text - (optional) str Response text content to mock, with automatic content-type header added. html - (optional) str Response HTML content to mock, with automatic content-type header added. json - (optional) str | list | dict Response JSON content to mock, with automatic content-type header added. stream - (optional) Iterable[bytes] Response stream to mock. Returns: Route","title":".respond()"},{"location":"api/#pass_through","text":"route. pass_through ( value=True ) Parameters: value - (optional) bool - default: True Mark route to pass through, sending matched requests to real server, e.g. don't mock . Returns: Route","title":".pass_through()"},{"location":"api/#response","text":"NOTE This is a partial reference for how to the instantiate the HTTPX Response class, e.g. not a RESPX class. httpx. Response ( status_code, headers=None, content=None, text=None, html=None, json=None, stream=None ) Parameters: status_code - int HTTP status code. headers - (optional) dict | httpx.Headers HTTP headers. content - (optional) bytes | str | Iterable[bytes] Raw content. text - (optional) str Text content, with automatic content-type header added. html - (optional) str HTML content, with automatic content-type header added. json - (optional) str | list | dict JSON content, with automatic content-type header added. stream - (optional) Iterable[bytes] Content stream .","title":"Response"},{"location":"api/#patterns","text":"","title":"Patterns"},{"location":"api/#m","text":"Creates a reusable pattern, combining multiple arguments using the AND operator. M ( *patterns, **lookups ) Parameters: patterns - (optional) args One or more pattern objects. lookups - (optional) kwargs One or more pattern keyword lookups , given as <pattern>__<lookup>=value . Returns: Pattern import respx from respx.patterns import M pattern = M ( host = \"example.org\" ) respx . route ( pattern ) See operators for advanced usage.","title":"M()"},{"location":"api/#method","text":"Matches request HTTP method , using eq as default lookup. Key: method Lookups: eq , in respx . route ( method = \"GET\" ) respx . route ( method__in = [ \"PUT\" , \"PATCH\" ])","title":"Method"},{"location":"api/#scheme","text":"Matches request URL scheme , using eq as default lookup. Key: scheme Lookups: eq , in respx . route ( scheme = \"https\" ) respx . route ( scheme__in = [ \"http\" , \"https\" ])","title":"Scheme"},{"location":"api/#host","text":"Matches request URL host , using eq as default lookup. Key: host Lookups: eq , regex , in respx . route ( host = \"example.org\" ) respx . route ( host__regex = r \"example\\.(org|com)\" ) respx . route ( host__in = [ \"example.org\" , \"example.com\" ])","title":"Host"},{"location":"api/#port","text":"Matches request URL port , using eq as default lookup. Key: port Lookups: eq , in respx . route ( port = 8000 ) respx . route ( port__in = [ 2375 , 2376 ])","title":"Port"},{"location":"api/#path","text":"Matches request URL path , using eq as default lookup. Key: path Lookups: eq , regex , startswith , in respx . route ( path = \"/api/foobar/\" ) respx . route ( path__regex = r \"^/api/(?P<slug>\\w+)/\" ) respx . route ( path__startswith = \"/api/\" ) respx . route ( path__in = [ \"/api/v1/foo/\" , \"/api/v2/foo/\" ])","title":"Path"},{"location":"api/#params","text":"Matches request URL query params , using contains as default lookup. Key: params Lookups: contains , eq respx . route ( params = { \"foo\" : \"bar\" , \"ham\" : \"spam\" }) respx . route ( params = [( \"foo\" , \"bar\" ), ( \"ham\" , \"spam\" )]) respx . route ( params = (( \"foo\" , \"bar\" ), ( \"ham\" , \"spam\" ))) respx . route ( params = \"foo=bar&ham=spam\" ) NOTE A request querystring with multiple parameters of the same name is treated as an ordered list when matching. ANY value Use mock.ANY as value to only match on parameter presence, e.g. respx.route(params={\"foo\": ANY}) .","title":"Params"},{"location":"api/#url","text":"Matches request URL . When no lookup is given, url works as a shorthand pattern, combining individual request URL parts, using the AND operator. Key: url Lookups: eq , regex , startswith respx . get ( \"//example.org/foo/\" ) # == M(host=\"example.org\", path=\"/foo/\") respx . get ( url__eq = \"https://example.org:8080/foobar/?ham=spam\" ) respx . get ( url__regex = r \"https://example.org/(?P<slug>\\w+)/\" ) respx . get ( url__startswith = \"https://example.org/api/\" ) respx . get ( \"all://*.example.org/foo/\" )","title":"URL"},{"location":"api/#content","text":"Matches request raw content , using eq as default lookup. Key: content Lookups: eq respx . post ( \"https://example.org/\" , content = \"foobar\" ) respx . post ( \"https://example.org/\" , content = b \"foobar\" )","title":"Content"},{"location":"api/#data","text":"Matches request form data , using eq as default lookup. Key: data Lookups: eq respx . post ( \"https://example.org/\" , data = { \"foo\" : \"bar\" })","title":"Data"},{"location":"api/#json","text":"Matches request json content, using eq as default lookup. Key: json Lookups: eq respx . post ( \"https://example.org/\" , json = { \"foo\" : \"bar\" }) The json pattern also supports path traversing, i.e. json__<path>=<value> . respx . post ( \"https://example.org/\" , json__foobar__0__ham = \"spam\" ) httpx . post ( \"https://example.org/\" , json = { \"foobar\" : [{ \"ham\" : \"spam\" }]})","title":"JSON"},{"location":"api/#headers","text":"Matches request headers , using contains as default lookup. Key: headers Lookups: contains , eq respx . route ( headers = { \"foo\" : \"bar\" , \"ham\" : \"spam\" }) respx . route ( headers = [( \"foo\" , \"bar\" ), ( \"ham\" , \"spam\" )])","title":"Headers"},{"location":"api/#cookies","text":"Matches request cookie header , using contains as default lookup. Key: cookies Lookups: contains , eq respx . route ( cookies = { \"foo\" : \"bar\" , \"ham\" : \"spam\" }) respx . route ( cookies = [( \"foo\" , \"bar\" ), ( \"ham\" , \"spam\" )])","title":"Cookies"},{"location":"api/#lookups","text":"","title":"Lookups"},{"location":"api/#eq","text":"M ( path = \"/foo/bar/\" ) M ( path__eq = \"/foo/bar/\" )","title":"eq"},{"location":"api/#contains","text":"Case-sensitive containment test. M ( params__contains = { \"id\" : \"123\" })","title":"contains"},{"location":"api/#in","text":"Case-sensitive within test. M ( method__in = [ \"PUT\" , \"PATCH\" ])","title":"in"},{"location":"api/#regex","text":"M ( path__regex = r \"^/api/(?P<slug>\\w+)/\" )","title":"regex"},{"location":"api/#startswith","text":"Case-sensitive starts-with. M ( path__startswith = \"/api/\" )","title":"startswith"},{"location":"api/#operators","text":"Patterns can be combined using bitwise operators, creating new patterns.","title":"Operators"},{"location":"api/#and","text":"Combines two Pattern s using and operator. M ( scheme = \"http\" ) & M ( host = \"example.org\" )","title":"AND (&amp;)"},{"location":"api/#or","text":"Combines two Pattern s using or operator. M ( method = \"PUT\" ) | M ( method = \"PATCH\" )","title":"OR (&amp;)"},{"location":"api/#invert","text":"Inverts a Pattern match. ~ M ( params = { \"foo\" : \"bar\" })","title":"INVERT (~)"},{"location":"examples/","text":"Test Case Examples Here's some test case examples, not exactly how-to , but to be inspired from. pytest Built-in Fixture RESPX includes the respx_mock pytest httpx fixture . import httpx def test_fixture ( respx_mock ): respx_mock . get ( \"https://foo.bar/\" ) . mock ( return_value = httpx . Response ( 204 )) response = httpx . get ( \"https://foo.bar/\" ) assert response . status_code == 204 Built-in Marker To configure the respx_mock fixture, use the respx marker . import httpx import pytest @pytest . mark . respx ( base_url = \"https://foo.bar\" ) def test_configured_fixture ( respx_mock ): respx_mock . get ( \"/baz/\" ) . mock ( return_value = httpx . Response ( 204 )) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . status_code == 204 See router configuration reference for more details. Custom Fixtures # conftest.py import pytest import respx from httpx import Response @pytest . fixture def mocked_api (): with respx . mock ( base_url = \"https://foo.bar\" , assert_all_called = False ) as respx_mock : users_route = respx_mock . get ( \"/users/\" , name = \"list_users\" ) users_route . return_value = Response ( 200 , json = []) ... yield respx_mock # test_api.py import httpx def test_list_users ( mocked_api ): response = httpx . get ( \"https://foo.bar/users/\" ) assert response . status_code == 200 assert response . json () == [] assert mocked_api [ \"list_users\" ] . called Session Scoped Fixtures If a session scoped RESPX fixture is used in an async context, you also need to broaden the pytest-asyncio event_loop fixture. You can use the session_event_loop utility for this. # conftest.py import pytest import respx from respx.fixtures import session_event_loop as event_loop # noqa: F401 @pytest . fixture ( scope = \"session\" ) async def mocked_api ( event_loop ): # noqa: F811 async with respx . mock ( base_url = \"https://foo.bar\" ) as respx_mock : ... yield respx_mock Async Test Cases import httpx import respx @respx . mock async def test_async_decorator (): async with httpx . AsyncClient () as client : route = respx . get ( \"https://example.org/\" ) response = await client . get ( \"https://example.org/\" ) assert route . called assert response . status_code == 200 async def test_async_ctx_manager (): async with respx . mock : async with httpx . AsyncClient () as client : route = respx . get ( \"https://example.org/\" ) response = await client . get ( \"https://example.org/\" ) assert route . called assert response . status_code == 200 unittest Regular Decoration # test_api.py import httpx import respx import unittest class APITestCase ( unittest . TestCase ): @respx . mock def test_some_endpoint ( self ): respx . get ( \"https://example.org/\" ) % 202 response = httpx . get ( \"https://example.org/\" ) self . assertEqual ( response . status_code , 202 ) Reuse SetUp & TearDown # testcases.py import respx from httpx import Response class MockedAPIMixin : @classmethod def setUpClass ( cls ): cls . mocked_api = respx . mock ( base_url = \"https://foo.bar\" , assert_all_called = False ) users_route = cls . mocked_api . get ( \"/users/\" , name = \"list_users\" ) users_route . return_value = Response ( 200 , json = []) ... def setUp ( self ): self . mocked_api . start () self . addCleanup ( self . mocked_api . stop ) # test_api.py import httpx import unittest from .testcases import MockedAPIMixin class APITestCase ( MockedAPIMixin , unittest . TestCase ): def test_list_users ( self ): response = httpx . get ( \"https://foo.bar/users/\" ) self . assertEqual ( response . status_code , 200 ) self . assertListEqual ( response . json (), []) self . assertTrue ( self . mocked_api [ \"list_users\" ] . called ) Async Test Cases import asynctest import httpx import respx class MyTestCase ( asynctest . TestCase ): @respx . mock async def test_async_decorator ( self ): async with httpx . AsyncClient () as client : route = respx . get ( \"https://example.org/\" ) response = await client . get ( \"https://example.org/\" ) assert route . called assert response . status_code == 200 async def test_async_ctx_manager ( self ): async with respx . mock : async with httpx . AsyncClient () as client : route = respx . get ( \"https://example.org/\" ) response = await client . get ( \"https://example.org/\" ) assert route . called assert response . status_code == 200","title":"Test Case Examples"},{"location":"examples/#test-case-examples","text":"Here's some test case examples, not exactly how-to , but to be inspired from.","title":"Test Case Examples"},{"location":"examples/#pytest","text":"","title":"pytest"},{"location":"examples/#built-in-fixture","text":"RESPX includes the respx_mock pytest httpx fixture . import httpx def test_fixture ( respx_mock ): respx_mock . get ( \"https://foo.bar/\" ) . mock ( return_value = httpx . Response ( 204 )) response = httpx . get ( \"https://foo.bar/\" ) assert response . status_code == 204","title":"Built-in Fixture"},{"location":"examples/#built-in-marker","text":"To configure the respx_mock fixture, use the respx marker . import httpx import pytest @pytest . mark . respx ( base_url = \"https://foo.bar\" ) def test_configured_fixture ( respx_mock ): respx_mock . get ( \"/baz/\" ) . mock ( return_value = httpx . Response ( 204 )) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . status_code == 204 See router configuration reference for more details.","title":"Built-in Marker"},{"location":"examples/#custom-fixtures","text":"# conftest.py import pytest import respx from httpx import Response @pytest . fixture def mocked_api (): with respx . mock ( base_url = \"https://foo.bar\" , assert_all_called = False ) as respx_mock : users_route = respx_mock . get ( \"/users/\" , name = \"list_users\" ) users_route . return_value = Response ( 200 , json = []) ... yield respx_mock # test_api.py import httpx def test_list_users ( mocked_api ): response = httpx . get ( \"https://foo.bar/users/\" ) assert response . status_code == 200 assert response . json () == [] assert mocked_api [ \"list_users\" ] . called Session Scoped Fixtures If a session scoped RESPX fixture is used in an async context, you also need to broaden the pytest-asyncio event_loop fixture. You can use the session_event_loop utility for this. # conftest.py import pytest import respx from respx.fixtures import session_event_loop as event_loop # noqa: F401 @pytest . fixture ( scope = \"session\" ) async def mocked_api ( event_loop ): # noqa: F811 async with respx . mock ( base_url = \"https://foo.bar\" ) as respx_mock : ... yield respx_mock","title":"Custom Fixtures"},{"location":"examples/#async-test-cases","text":"import httpx import respx @respx . mock async def test_async_decorator (): async with httpx . AsyncClient () as client : route = respx . get ( \"https://example.org/\" ) response = await client . get ( \"https://example.org/\" ) assert route . called assert response . status_code == 200 async def test_async_ctx_manager (): async with respx . mock : async with httpx . AsyncClient () as client : route = respx . get ( \"https://example.org/\" ) response = await client . get ( \"https://example.org/\" ) assert route . called assert response . status_code == 200","title":"Async Test Cases"},{"location":"examples/#unittest","text":"","title":"unittest"},{"location":"examples/#regular-decoration","text":"# test_api.py import httpx import respx import unittest class APITestCase ( unittest . TestCase ): @respx . mock def test_some_endpoint ( self ): respx . get ( \"https://example.org/\" ) % 202 response = httpx . get ( \"https://example.org/\" ) self . assertEqual ( response . status_code , 202 )","title":"Regular Decoration"},{"location":"examples/#reuse-setup-teardown","text":"# testcases.py import respx from httpx import Response class MockedAPIMixin : @classmethod def setUpClass ( cls ): cls . mocked_api = respx . mock ( base_url = \"https://foo.bar\" , assert_all_called = False ) users_route = cls . mocked_api . get ( \"/users/\" , name = \"list_users\" ) users_route . return_value = Response ( 200 , json = []) ... def setUp ( self ): self . mocked_api . start () self . addCleanup ( self . mocked_api . stop ) # test_api.py import httpx import unittest from .testcases import MockedAPIMixin class APITestCase ( MockedAPIMixin , unittest . TestCase ): def test_list_users ( self ): response = httpx . get ( \"https://foo.bar/users/\" ) self . assertEqual ( response . status_code , 200 ) self . assertListEqual ( response . json (), []) self . assertTrue ( self . mocked_api [ \"list_users\" ] . called )","title":"Reuse SetUp &amp; TearDown"},{"location":"examples/#async-test-cases_1","text":"import asynctest import httpx import respx class MyTestCase ( asynctest . TestCase ): @respx . mock async def test_async_decorator ( self ): async with httpx . AsyncClient () as client : route = respx . get ( \"https://example.org/\" ) response = await client . get ( \"https://example.org/\" ) assert route . called assert response . status_code == 200 async def test_async_ctx_manager ( self ): async with respx . mock : async with httpx . AsyncClient () as client : route = respx . get ( \"https://example.org/\" ) response = await client . get ( \"https://example.org/\" ) assert route . called assert response . status_code == 200","title":"Async Test Cases"},{"location":"guide/","text":"User Guide RESPX is a mock router, capturing requests sent by HTTPX , mocking their responses. Inspired by the flexible query API of the Django ORM, requests are filtered and matched against routes and their request patterns and lookups . Request patterns are bits of the request, like host method path etc, with given lookup values, combined using bitwise operators to form a Route , i.e. respx.route(path__regex=...) A captured request, matching a Route , resolves to a mocked httpx.Response , or triggers a given side effect . To skip mocking a specific request, a route can be marked to pass through . Mock HTTPX To patch HTTPX , and activate the RESPX router, use the respx.mock decorator/context manager, or the respx_mock pytest fixture. Using the Decorator import httpx import respx @respx . mock def test_decorator (): my_route = respx . get ( \"https://example.org/\" ) response = httpx . get ( \"https://example.org/\" ) assert my_route . called assert response . status_code == 200 Using the Context Manager import httpx import respx def test_ctx_manager (): with respx . mock : my_route = respx . get ( \"https://example.org/\" ) response = httpx . get ( \"https://example.org/\" ) assert my_route . called assert response . status_code == 200 Using the pytest Fixture import httpx def test_fixture ( respx_mock ): my_route = respx_mock . get ( \"https://example.org/\" ) response = httpx . get ( \"https://example.org/\" ) assert my_route . called assert response . status_code == 200 Router Settings The RESPX router can be configured with built-in assertion checks and an optional base URL . By configuring, an isolated router is created, and settings are locally bound to the routes added. Either of the decorator, context manager and fixture takes the same configuration arguments. See router configuration reference for more details. Configure the Decorator When decorating a test case with configured router settings, the test function will receive the router instance as a respx_mock argument. @respx . mock ( ... ) def test_something ( respx_mock ): ... Configure the Context Manager When passing settings to the context manager, the configured router instance will be yielded . with respx . mock ( ... ) as respx_mock : ... Configure the Fixture To configure the router when using the pytest fixture, decorate the test case with the respx pytest marker . @pytest . mark . respx ( ... ) def test_something ( respx_mock ): ... Base URL When adding a lot of routes, sharing the same domain/prefix, you can configure the router with a base_url to be used for added routes. import httpx import respx from httpx import Response @respx . mock ( base_url = \"https://example.org/api/\" ) async def test_something ( respx_mock ): async with httpx . AsyncClient ( base_url = \"https://example.org/api/\" ) as client : respx_mock . get ( \"/baz/\" ) . mock ( return_value = Response ( 200 , text = \"Baz\" )) response = await client . get ( \"/baz/\" ) assert response . text == \"Baz\" Assert all Mocked By default, asserts that all sent and captured HTTPX requests are routed and mocked. @respx . mock ( assert_all_mocked = True ) def test_something ( respx_mock ): response = httpx . get ( \"https://example.org/\" ) # Not mocked, will raise If disabled , all non-routed requests will be auto-mocked with status code 200 . @respx . mock ( assert_all_mocked = False ) def test_something ( respx_mock ): response = httpx . get ( \"https://example.org/\" ) # Will auto-mock assert response . status_code == 200 Assert all Called By default, asserts that all added and mocked routes were called when exiting decorated test case, context manager scope or exiting a text case using the pytest fixture. @respx . mock ( assert_all_called = True ) def test_something ( respx_mock ): respx_mock . get ( \"https://example.org/\" ) respx_mock . get ( \"https://some.url/\" ) # Not called, will fail the test response = httpx . get ( \"https://example.org/\" ) @respx . mock ( assert_all_called = False ) def test_something ( respx_mock ): respx_mock . get ( \"https://example.org/\" ) respx_mock . get ( \"https://some.url/\" ) # Not called, yet not asserted response = httpx . get ( \"https://example.org/\" ) assert response . status_code == 200 Routing Requests The easiest way to add routes is to use the HTTP Method helpers. For full control over the request pattern matching, use the route API. Routes are matched and routed in added order . This means that routes with more specific patterns should to be added earlier than the ones with less \"details\". HTTP Method Helpers Each HTTP method has a helper function ( get , options , head , post , put , patch , delete ), shortcutting the route API. my_route = respx . get ( \"https://example.org/\" , params = { \"foo\" : \"bar\" }) response = httpx . get ( \"https://example.org/\" , params = { \"foo\" : \"bar\" }) assert my_route . called assert response . status_code == 200 See .get(), .post(), ... helpers reference for more details. Route API Patterns With the route API, you define a combined pattern to match, capturing a sent request. my_route = respx . route ( method = \"GET\" , host = \"example.org\" , path = \"/foobar/\" ) response = httpx . get ( \"https://example.org/foobar/\" ) assert my_route . called assert response . status_code == 200 See .route() reference for more details. Lookups Each pattern has a default lookup. To specify what lookup to use, add a __<lookup> suffix. respx . route ( method__in = [ \"PUT\" , \"PATCH\" ]) Combining Patterns For even more flexibility, you can define combined patterns using the M() object , together with bitwise operators ( & , |, ~ ), creating a reusable pattern. hosts_pattern = M ( host = \"example.org\" ) | M ( host = \"example.com\" ) my_route = respx . route ( hosts_pattern , method = \"GET\" , path = \"/foo/\" ) response = httpx . get ( \"http://example.org/foo/\" ) assert response . status_code == 200 assert my_route . called response = httpx . get ( \"https://example.com/foo/\" ) assert response . status_code == 200 assert my_route . call_count == 2 NOTE M(url=\"//example.org/foobar/\") is equal to M(host=\"example.org\") & M(path=\"/foobar/\") Named Routes Routes can be named when added, and later accessed through the respx.routes mapping. This is useful when a route is added outside the test case, e.g. access or assert route calls. import httpx import respx # Added somewhere else respx . get ( \"https://example.org/\" , name = \"home\" ) @respx . mock def test_route_call (): httpx . get ( \"https://example.org/\" ) assert respx . routes [ \"home\" ] . called assert respx . routes [ \"home\" ] . call_count == 1 last_home_response = respx . routes [ \"home\" ] . calls . last . response assert last_home_response . status_code == 200 Reusable Routers As described under settings , an isolated router is created when calling respx.mock(...) . Isolated routers are useful when mocking multiple remote APIs, allowing grouped routes per API, and to be mocked individually or stacked for reuse across tests. Use the router instance as decorator or context manager to patch HTTPX and activate the routes. import httpx import respx from httpx import Response api_mock = respx . mock ( assert_all_called = False ) api_mock . route ( url = \"https://api.foo.bar/baz/\" , name = \"baz\" , ) . mock ( return_value = Response ( 200 , json = { \"name\" : \"baz\" }), ) ... @api_mock def test_decorator (): response = httpx . get ( \"https://api.foo.bar/baz/\" ) assert response . status_code == 200 assert response . json () == { \"name\" : \"baz\" } assert api_mock [ \"baz\" ] . called def test_ctx_manager (): with api_mock : ... NOTE Named routes in a reusable router can be directly accessed via my_mock_router[<route name>] Route with an App As an alternative one can route and mock responses with an app by passing either a respx.WSGIHandler or respx.ASGIHandler as side effect when mocking. Sync App Example import httpx import respx from flask import Flask app = Flask ( \"foobar\" ) @app . route ( \"/baz/\" ) def baz (): return { \"ham\" : \"spam\" } @respx . mock ( base_url = \"https://foo.bar/\" ) def test_baz ( respx_mock ): app_route = respx_mock . route () . mock ( side_effect = WSGIHandler ( app )) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . json () == { \"ham\" : \"spam\" } assert app_route . called Async App Example import httpx import respx from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route async def baz ( request ): return JSONResponse ({ \"ham\" : \"spam\" }) app = Starlette ( routes = [ Route ( \"/baz/\" , baz )]) @respx . mock ( base_url = \"https://foo.bar/\" ) async def test_baz ( respx_mock ): app_route = respx_mock . route () . mock ( side_effect = ASGIHandler ( app )) response = await httpx . AsyncClient () . get ( \"https://foo.bar/baz/\" ) assert response . json () == { \"ham\" : \"spam\" } assert app_route . called Mocking Responses To mock a route response, use <route>.mock(...) to either... set the httpx.Response to be returned . set a side effect to be triggered. The route's mock interface is inspired by pythons built-in Mock() object, e.g. side_effect has precedence over return_value , side effects can either be functions, exceptions or an iterable, raising StopIteration when \"exhausted\" etc. Mock a Response Create a mocked HTTPX Response object and pass it as return_value . respx . get ( \"https://example.org/\" ) . mock ( return_value = Response ( 204 )) See .mock() reference for more details. You can also use the <route>.return_value setter . route = respx . get ( \"https://example.org/\" ) route . return_value = Response ( 200 , json = { \"foo\" : \"bar\" }) Mock with a Side Effect RESPX side effects works just like the python Mock side effects. It can either be a function to call, an exception to raise, or an iterable of responses/exceptions to respond with in order, for repeated requests. respx . get ( \"https://example.org/\" ) . mock ( side_effect =... ) You can also use the <route>.side_effect setter . route = respx . get ( \"https://example.org/\" ) route . side_effect = ... Functions Function side effects will be called with the captured request argument, and should either... return a mocked Response . raise an Exception to simulate a request error. return None to treat the route as a non-match , continuing testing further routes. return the input Request to pass through . import httpx import respx def my_side_effect ( request ): return httpx . Response ( 201 ) @respx . mock def test_side_effect (): respx . post ( \"https://example.org/\" ) . mock ( side_effect = my_side_effect ) response = httpx . post ( \"https://example.org/\" ) assert response . status_code == 201 Optionally, a side effect can include a route argument for cases where call stats, or modifying the route within the side effect, is needed. import httpx import respx def my_side_effect ( request , route ): return httpx . Response ( 201 , json = { \"id\" : route . call_count + 1 }) @respx . mock def test_side_effect (): respx . post ( \"https://example.org/\" ) . mock ( side_effect = my_side_effect ) response = httpx . post ( \"https://example.org/\" ) assert response . json () == { \"id\" : 1 } response = httpx . post ( \"https://example.org/\" ) assert response . json () == { \"id\" : 2 } If any of the route patterns are using a regex lookup , containing named groups , the regex groups will be passed as kwargs to the side effect . import httpx import respx def my_side_effect ( request , slug ): return httpx . Response ( 200 , json = { \"slug\" : slug }) @respx . mock def test_side_effect_kwargs (): route = respx . route ( url__regex = r \"https://example.org/(?P<slug>\\w+)/\" ) route . side_effect = my_side_effect response = httpx . get ( \"https://example.org/foobar/\" ) assert response . status_code == 200 assert response . json () == { \"slug\" : \"foobar\" } A route can even decorate the function to be used as side effect . import httpx import rexpx @respx . route ( url__regex = r \"https://example.org/(?P<user>\\w+)/\" , name = \"user\" ) def user_api ( request , user ): return httpx . Response ( 200 , json = { \"user\" : user }) @respx . mock def test_user_api (): response = httpx . get ( \"https://example.org/lundberg/\" ) assert response . status_code == 200 assert response . json () == { \"user\" : \"lundberg\" } assert respx . routes [ \"user\" ] . called Exceptions To simulate a request error, pass a httpx.HTTPError subclass , or any Exception as side effect . import httpx import respx @respx . mock def test_connection_error (): respx . get ( \"https://example.org/\" ) . mock ( side_effect = httpx . ConnectError ) with pytest . raises ( httpx . ConnectError ): httpx . get ( \"https://example.org/\" ) Iterable If the side effect is an iterable , each repeated request will get the next Response returned, or exception raised, from the iterable. import httpx import respx @respx . mock def test_stacked_responses (): route = respx . get ( \"https://example.org/\" ) route . side_effect = [ httpx . Response ( 404 ), httpx . Response ( 200 ), ] response1 = httpx . get ( \"https://example.org/\" ) response2 = httpx . get ( \"https://example.org/\" ) assert response1 . status_code == 404 assert response2 . status_code == 200 assert route . call_count == 2 Shortcuts Respond For convenience, <route>.respond(...) can be used as a shortcut to return_value . respx . post ( \"https://example.org/\" ) . respond ( 201 ) See .respond() reference for more details. Modulo For simple mocking, a quick way is to use the python modulo ( % ) operator to mock the response. The right-hand modulo argument can either be ... An int representing the status_code to mock: respx . get ( \"https://example.org/\" ) % 204 response = httpx . get ( \"https://example.org/\" ) assert response . status_code == 204 A dict used as kwargs to create a mocked HTTPX Response , with status code 200 by default: respx . get ( \"https://example.org/\" ) % dict ( json = { \"foo\" : \"bar\" }) response = httpx . get ( \"https://example.org/\" ) assert response . status_code == 200 assert response . json () == { \"foo\" : \"bar\" } A HTTPX Response object: respx . get ( \"https://example.org/\" ) % Response ( 418 ) response = httpx . get ( \"https://example.org/\" ) assert response . status_code == httpx . codes . IM_A_TEAPOT Rollback When exiting a decorated test case, or context manager , the routes and their mocked values, i.e. return_value and side_effect , will be rolled back and restored to their initial state. This means that you can safely modify existing routes, or add new ones, within a test case, without affecting other tests that are using the same router. import httpx import respx # Initial routes mock_router = respx . mock ( base_url = \"https://example.org\" ) mock_router . get ( path__regex = \"/user/(?P<pk>\\d+)/\" , name = \"user\" ) % 404 ... @mock_router def test_user_exists (): # This change will be rolled back after this test case mock_router [ \"user\" ] . return_value = httpx . Response ( 200 ) response = httpx . get ( \"https://example.org/user/123/\" ) assert response . status_code == 200 @mock_router def test_user_not_found (): response = httpx . get ( \"https://example.org/user/123/\" ) assert response . status_code == 404 Pass Through If you want a route to not capture and mock a request response, use .pass_through() . import httpx import respx @respx . mock def test_remote_response (): respx . route ( host = \"localhost\" ) . pass_through () response = httpx . get ( \"http://localhost:8000/\" ) # response from server See .pass_through() reference for more details. Mock without patching HTTPX If you don't need to patch HTTPX , use httpx.MockTransport with a REPX router as handler, when instantiating your client. import httpx import respx from respx.transports import MockTransport router = respx . Router () router . post ( \"https://example.org/\" ) % 404 def test_client (): mock_transport = httpx . MockTransport ( router . handler ) with httpx . Client ( transport = mock_transport ) as client : response = client . post ( \"https://example.org/\" ) assert response . status_code == 404 NOTE Use httpx.MockTransport(router.async_handler) when using an httpx.AsyncClient . Hint You can use RESPX not only to mock out HTTPX , but actually mock any library using HTTP Core transports. Call History The respx API includes a .calls object, containing captured ( request , response ) named tuples and MagicMock's bells and whistles , i.e. call_count , assert_called etc. Asserting calls assert respx . calls . called assert respx . calls . call_count == 1 respx . calls . assert_called () respx . calls . assert_not_called () respx . calls . assert_called_once () Retrieving mocked calls A matched and mocked Call can be retrieved from call history, by either unpacking... request , response = respx . calls . last request , response = respx . calls [ - 2 ] # by call order ...or by accessing request or response directly... last_request = respx . calls . last . request assert respx . calls . last . response . status_code == 200 Local route calls Each Route object has its own .calls , along with .called and .call_count shortcuts. import httpx import respx @respx . mock def test_route_call_stats (): route = respx . post ( \"https://example.org/baz/\" ) % 201 httpx . post ( \"https://example.org/baz/\" ) assert route . calls . last . request . url . path == \"/baz/\" assert route . calls . last . response . status_code == 201 assert route . called assert route . call_count == 1 route . calls . assert_called_once () Reset History The call history will automatically reset when exiting mocked context, i.e. leaving a decorated test case, or context manager scope. To manually reset call stats during a test case, use respx.reset() or <your_router>.reset() . import httpx import respx @respx . mock def test_reset (): respx . post ( \"https://foo.bar/baz/\" ) httpx . post ( \"https://foo.bar/baz/\" ) assert respx . calls . call_count == 1 respx . calls . assert_called_once () respx . reset () assert len ( respx . calls ) == 0 assert respx . calls . call_count == 0 respx . calls . assert_not_called ()","title":"User Guide"},{"location":"guide/#user-guide","text":"RESPX is a mock router, capturing requests sent by HTTPX , mocking their responses. Inspired by the flexible query API of the Django ORM, requests are filtered and matched against routes and their request patterns and lookups . Request patterns are bits of the request, like host method path etc, with given lookup values, combined using bitwise operators to form a Route , i.e. respx.route(path__regex=...) A captured request, matching a Route , resolves to a mocked httpx.Response , or triggers a given side effect . To skip mocking a specific request, a route can be marked to pass through .","title":"User Guide"},{"location":"guide/#mock-httpx","text":"To patch HTTPX , and activate the RESPX router, use the respx.mock decorator/context manager, or the respx_mock pytest fixture.","title":"Mock HTTPX"},{"location":"guide/#using-the-decorator","text":"import httpx import respx @respx . mock def test_decorator (): my_route = respx . get ( \"https://example.org/\" ) response = httpx . get ( \"https://example.org/\" ) assert my_route . called assert response . status_code == 200","title":"Using the Decorator"},{"location":"guide/#using-the-context-manager","text":"import httpx import respx def test_ctx_manager (): with respx . mock : my_route = respx . get ( \"https://example.org/\" ) response = httpx . get ( \"https://example.org/\" ) assert my_route . called assert response . status_code == 200","title":"Using the Context Manager"},{"location":"guide/#using-the-pytest-fixture","text":"import httpx def test_fixture ( respx_mock ): my_route = respx_mock . get ( \"https://example.org/\" ) response = httpx . get ( \"https://example.org/\" ) assert my_route . called assert response . status_code == 200","title":"Using the pytest Fixture"},{"location":"guide/#router-settings","text":"The RESPX router can be configured with built-in assertion checks and an optional base URL . By configuring, an isolated router is created, and settings are locally bound to the routes added. Either of the decorator, context manager and fixture takes the same configuration arguments. See router configuration reference for more details. Configure the Decorator When decorating a test case with configured router settings, the test function will receive the router instance as a respx_mock argument. @respx . mock ( ... ) def test_something ( respx_mock ): ... Configure the Context Manager When passing settings to the context manager, the configured router instance will be yielded . with respx . mock ( ... ) as respx_mock : ... Configure the Fixture To configure the router when using the pytest fixture, decorate the test case with the respx pytest marker . @pytest . mark . respx ( ... ) def test_something ( respx_mock ): ...","title":"Router Settings"},{"location":"guide/#base-url","text":"When adding a lot of routes, sharing the same domain/prefix, you can configure the router with a base_url to be used for added routes. import httpx import respx from httpx import Response @respx . mock ( base_url = \"https://example.org/api/\" ) async def test_something ( respx_mock ): async with httpx . AsyncClient ( base_url = \"https://example.org/api/\" ) as client : respx_mock . get ( \"/baz/\" ) . mock ( return_value = Response ( 200 , text = \"Baz\" )) response = await client . get ( \"/baz/\" ) assert response . text == \"Baz\"","title":"Base URL"},{"location":"guide/#assert-all-mocked","text":"By default, asserts that all sent and captured HTTPX requests are routed and mocked. @respx . mock ( assert_all_mocked = True ) def test_something ( respx_mock ): response = httpx . get ( \"https://example.org/\" ) # Not mocked, will raise If disabled , all non-routed requests will be auto-mocked with status code 200 . @respx . mock ( assert_all_mocked = False ) def test_something ( respx_mock ): response = httpx . get ( \"https://example.org/\" ) # Will auto-mock assert response . status_code == 200","title":"Assert all Mocked"},{"location":"guide/#assert-all-called","text":"By default, asserts that all added and mocked routes were called when exiting decorated test case, context manager scope or exiting a text case using the pytest fixture. @respx . mock ( assert_all_called = True ) def test_something ( respx_mock ): respx_mock . get ( \"https://example.org/\" ) respx_mock . get ( \"https://some.url/\" ) # Not called, will fail the test response = httpx . get ( \"https://example.org/\" ) @respx . mock ( assert_all_called = False ) def test_something ( respx_mock ): respx_mock . get ( \"https://example.org/\" ) respx_mock . get ( \"https://some.url/\" ) # Not called, yet not asserted response = httpx . get ( \"https://example.org/\" ) assert response . status_code == 200","title":"Assert all Called"},{"location":"guide/#routing-requests","text":"The easiest way to add routes is to use the HTTP Method helpers. For full control over the request pattern matching, use the route API. Routes are matched and routed in added order . This means that routes with more specific patterns should to be added earlier than the ones with less \"details\".","title":"Routing Requests"},{"location":"guide/#http-method-helpers","text":"Each HTTP method has a helper function ( get , options , head , post , put , patch , delete ), shortcutting the route API. my_route = respx . get ( \"https://example.org/\" , params = { \"foo\" : \"bar\" }) response = httpx . get ( \"https://example.org/\" , params = { \"foo\" : \"bar\" }) assert my_route . called assert response . status_code == 200 See .get(), .post(), ... helpers reference for more details.","title":"HTTP Method Helpers"},{"location":"guide/#route-api","text":"","title":"Route API"},{"location":"guide/#patterns","text":"With the route API, you define a combined pattern to match, capturing a sent request. my_route = respx . route ( method = \"GET\" , host = \"example.org\" , path = \"/foobar/\" ) response = httpx . get ( \"https://example.org/foobar/\" ) assert my_route . called assert response . status_code == 200 See .route() reference for more details.","title":"Patterns"},{"location":"guide/#lookups","text":"Each pattern has a default lookup. To specify what lookup to use, add a __<lookup> suffix. respx . route ( method__in = [ \"PUT\" , \"PATCH\" ])","title":"Lookups"},{"location":"guide/#combining-patterns","text":"For even more flexibility, you can define combined patterns using the M() object , together with bitwise operators ( & , |, ~ ), creating a reusable pattern. hosts_pattern = M ( host = \"example.org\" ) | M ( host = \"example.com\" ) my_route = respx . route ( hosts_pattern , method = \"GET\" , path = \"/foo/\" ) response = httpx . get ( \"http://example.org/foo/\" ) assert response . status_code == 200 assert my_route . called response = httpx . get ( \"https://example.com/foo/\" ) assert response . status_code == 200 assert my_route . call_count == 2 NOTE M(url=\"//example.org/foobar/\") is equal to M(host=\"example.org\") & M(path=\"/foobar/\")","title":"Combining Patterns"},{"location":"guide/#named-routes","text":"Routes can be named when added, and later accessed through the respx.routes mapping. This is useful when a route is added outside the test case, e.g. access or assert route calls. import httpx import respx # Added somewhere else respx . get ( \"https://example.org/\" , name = \"home\" ) @respx . mock def test_route_call (): httpx . get ( \"https://example.org/\" ) assert respx . routes [ \"home\" ] . called assert respx . routes [ \"home\" ] . call_count == 1 last_home_response = respx . routes [ \"home\" ] . calls . last . response assert last_home_response . status_code == 200","title":"Named Routes"},{"location":"guide/#reusable-routers","text":"As described under settings , an isolated router is created when calling respx.mock(...) . Isolated routers are useful when mocking multiple remote APIs, allowing grouped routes per API, and to be mocked individually or stacked for reuse across tests. Use the router instance as decorator or context manager to patch HTTPX and activate the routes. import httpx import respx from httpx import Response api_mock = respx . mock ( assert_all_called = False ) api_mock . route ( url = \"https://api.foo.bar/baz/\" , name = \"baz\" , ) . mock ( return_value = Response ( 200 , json = { \"name\" : \"baz\" }), ) ... @api_mock def test_decorator (): response = httpx . get ( \"https://api.foo.bar/baz/\" ) assert response . status_code == 200 assert response . json () == { \"name\" : \"baz\" } assert api_mock [ \"baz\" ] . called def test_ctx_manager (): with api_mock : ... NOTE Named routes in a reusable router can be directly accessed via my_mock_router[<route name>]","title":"Reusable Routers"},{"location":"guide/#route-with-an-app","text":"As an alternative one can route and mock responses with an app by passing either a respx.WSGIHandler or respx.ASGIHandler as side effect when mocking. Sync App Example import httpx import respx from flask import Flask app = Flask ( \"foobar\" ) @app . route ( \"/baz/\" ) def baz (): return { \"ham\" : \"spam\" } @respx . mock ( base_url = \"https://foo.bar/\" ) def test_baz ( respx_mock ): app_route = respx_mock . route () . mock ( side_effect = WSGIHandler ( app )) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . json () == { \"ham\" : \"spam\" } assert app_route . called Async App Example import httpx import respx from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route async def baz ( request ): return JSONResponse ({ \"ham\" : \"spam\" }) app = Starlette ( routes = [ Route ( \"/baz/\" , baz )]) @respx . mock ( base_url = \"https://foo.bar/\" ) async def test_baz ( respx_mock ): app_route = respx_mock . route () . mock ( side_effect = ASGIHandler ( app )) response = await httpx . AsyncClient () . get ( \"https://foo.bar/baz/\" ) assert response . json () == { \"ham\" : \"spam\" } assert app_route . called","title":"Route with an App"},{"location":"guide/#mocking-responses","text":"To mock a route response, use <route>.mock(...) to either... set the httpx.Response to be returned . set a side effect to be triggered. The route's mock interface is inspired by pythons built-in Mock() object, e.g. side_effect has precedence over return_value , side effects can either be functions, exceptions or an iterable, raising StopIteration when \"exhausted\" etc.","title":"Mocking Responses"},{"location":"guide/#mock-a-response","text":"Create a mocked HTTPX Response object and pass it as return_value . respx . get ( \"https://example.org/\" ) . mock ( return_value = Response ( 204 )) See .mock() reference for more details. You can also use the <route>.return_value setter . route = respx . get ( \"https://example.org/\" ) route . return_value = Response ( 200 , json = { \"foo\" : \"bar\" })","title":"Mock a Response"},{"location":"guide/#mock-with-a-side-effect","text":"RESPX side effects works just like the python Mock side effects. It can either be a function to call, an exception to raise, or an iterable of responses/exceptions to respond with in order, for repeated requests. respx . get ( \"https://example.org/\" ) . mock ( side_effect =... ) You can also use the <route>.side_effect setter . route = respx . get ( \"https://example.org/\" ) route . side_effect = ...","title":"Mock with a Side Effect"},{"location":"guide/#functions","text":"Function side effects will be called with the captured request argument, and should either... return a mocked Response . raise an Exception to simulate a request error. return None to treat the route as a non-match , continuing testing further routes. return the input Request to pass through . import httpx import respx def my_side_effect ( request ): return httpx . Response ( 201 ) @respx . mock def test_side_effect (): respx . post ( \"https://example.org/\" ) . mock ( side_effect = my_side_effect ) response = httpx . post ( \"https://example.org/\" ) assert response . status_code == 201 Optionally, a side effect can include a route argument for cases where call stats, or modifying the route within the side effect, is needed. import httpx import respx def my_side_effect ( request , route ): return httpx . Response ( 201 , json = { \"id\" : route . call_count + 1 }) @respx . mock def test_side_effect (): respx . post ( \"https://example.org/\" ) . mock ( side_effect = my_side_effect ) response = httpx . post ( \"https://example.org/\" ) assert response . json () == { \"id\" : 1 } response = httpx . post ( \"https://example.org/\" ) assert response . json () == { \"id\" : 2 } If any of the route patterns are using a regex lookup , containing named groups , the regex groups will be passed as kwargs to the side effect . import httpx import respx def my_side_effect ( request , slug ): return httpx . Response ( 200 , json = { \"slug\" : slug }) @respx . mock def test_side_effect_kwargs (): route = respx . route ( url__regex = r \"https://example.org/(?P<slug>\\w+)/\" ) route . side_effect = my_side_effect response = httpx . get ( \"https://example.org/foobar/\" ) assert response . status_code == 200 assert response . json () == { \"slug\" : \"foobar\" } A route can even decorate the function to be used as side effect . import httpx import rexpx @respx . route ( url__regex = r \"https://example.org/(?P<user>\\w+)/\" , name = \"user\" ) def user_api ( request , user ): return httpx . Response ( 200 , json = { \"user\" : user }) @respx . mock def test_user_api (): response = httpx . get ( \"https://example.org/lundberg/\" ) assert response . status_code == 200 assert response . json () == { \"user\" : \"lundberg\" } assert respx . routes [ \"user\" ] . called","title":"Functions"},{"location":"guide/#exceptions","text":"To simulate a request error, pass a httpx.HTTPError subclass , or any Exception as side effect . import httpx import respx @respx . mock def test_connection_error (): respx . get ( \"https://example.org/\" ) . mock ( side_effect = httpx . ConnectError ) with pytest . raises ( httpx . ConnectError ): httpx . get ( \"https://example.org/\" )","title":"Exceptions"},{"location":"guide/#iterable","text":"If the side effect is an iterable , each repeated request will get the next Response returned, or exception raised, from the iterable. import httpx import respx @respx . mock def test_stacked_responses (): route = respx . get ( \"https://example.org/\" ) route . side_effect = [ httpx . Response ( 404 ), httpx . Response ( 200 ), ] response1 = httpx . get ( \"https://example.org/\" ) response2 = httpx . get ( \"https://example.org/\" ) assert response1 . status_code == 404 assert response2 . status_code == 200 assert route . call_count == 2","title":"Iterable"},{"location":"guide/#shortcuts","text":"","title":"Shortcuts"},{"location":"guide/#respond","text":"For convenience, <route>.respond(...) can be used as a shortcut to return_value . respx . post ( \"https://example.org/\" ) . respond ( 201 ) See .respond() reference for more details.","title":"Respond"},{"location":"guide/#modulo","text":"For simple mocking, a quick way is to use the python modulo ( % ) operator to mock the response. The right-hand modulo argument can either be ... An int representing the status_code to mock: respx . get ( \"https://example.org/\" ) % 204 response = httpx . get ( \"https://example.org/\" ) assert response . status_code == 204 A dict used as kwargs to create a mocked HTTPX Response , with status code 200 by default: respx . get ( \"https://example.org/\" ) % dict ( json = { \"foo\" : \"bar\" }) response = httpx . get ( \"https://example.org/\" ) assert response . status_code == 200 assert response . json () == { \"foo\" : \"bar\" } A HTTPX Response object: respx . get ( \"https://example.org/\" ) % Response ( 418 ) response = httpx . get ( \"https://example.org/\" ) assert response . status_code == httpx . codes . IM_A_TEAPOT","title":"Modulo"},{"location":"guide/#rollback","text":"When exiting a decorated test case, or context manager , the routes and their mocked values, i.e. return_value and side_effect , will be rolled back and restored to their initial state. This means that you can safely modify existing routes, or add new ones, within a test case, without affecting other tests that are using the same router. import httpx import respx # Initial routes mock_router = respx . mock ( base_url = \"https://example.org\" ) mock_router . get ( path__regex = \"/user/(?P<pk>\\d+)/\" , name = \"user\" ) % 404 ... @mock_router def test_user_exists (): # This change will be rolled back after this test case mock_router [ \"user\" ] . return_value = httpx . Response ( 200 ) response = httpx . get ( \"https://example.org/user/123/\" ) assert response . status_code == 200 @mock_router def test_user_not_found (): response = httpx . get ( \"https://example.org/user/123/\" ) assert response . status_code == 404","title":"Rollback"},{"location":"guide/#pass-through","text":"If you want a route to not capture and mock a request response, use .pass_through() . import httpx import respx @respx . mock def test_remote_response (): respx . route ( host = \"localhost\" ) . pass_through () response = httpx . get ( \"http://localhost:8000/\" ) # response from server See .pass_through() reference for more details.","title":"Pass Through"},{"location":"guide/#mock-without-patching-httpx","text":"If you don't need to patch HTTPX , use httpx.MockTransport with a REPX router as handler, when instantiating your client. import httpx import respx from respx.transports import MockTransport router = respx . Router () router . post ( \"https://example.org/\" ) % 404 def test_client (): mock_transport = httpx . MockTransport ( router . handler ) with httpx . Client ( transport = mock_transport ) as client : response = client . post ( \"https://example.org/\" ) assert response . status_code == 404 NOTE Use httpx.MockTransport(router.async_handler) when using an httpx.AsyncClient . Hint You can use RESPX not only to mock out HTTPX , but actually mock any library using HTTP Core transports.","title":"Mock without patching HTTPX"},{"location":"guide/#call-history","text":"The respx API includes a .calls object, containing captured ( request , response ) named tuples and MagicMock's bells and whistles , i.e. call_count , assert_called etc.","title":"Call History"},{"location":"guide/#asserting-calls","text":"assert respx . calls . called assert respx . calls . call_count == 1 respx . calls . assert_called () respx . calls . assert_not_called () respx . calls . assert_called_once ()","title":"Asserting calls"},{"location":"guide/#retrieving-mocked-calls","text":"A matched and mocked Call can be retrieved from call history, by either unpacking... request , response = respx . calls . last request , response = respx . calls [ - 2 ] # by call order ...or by accessing request or response directly... last_request = respx . calls . last . request assert respx . calls . last . response . status_code == 200","title":"Retrieving mocked calls"},{"location":"guide/#local-route-calls","text":"Each Route object has its own .calls , along with .called and .call_count shortcuts. import httpx import respx @respx . mock def test_route_call_stats (): route = respx . post ( \"https://example.org/baz/\" ) % 201 httpx . post ( \"https://example.org/baz/\" ) assert route . calls . last . request . url . path == \"/baz/\" assert route . calls . last . response . status_code == 201 assert route . called assert route . call_count == 1 route . calls . assert_called_once ()","title":"Local route calls"},{"location":"guide/#reset-history","text":"The call history will automatically reset when exiting mocked context, i.e. leaving a decorated test case, or context manager scope. To manually reset call stats during a test case, use respx.reset() or <your_router>.reset() . import httpx import respx @respx . mock def test_reset (): respx . post ( \"https://foo.bar/baz/\" ) httpx . post ( \"https://foo.bar/baz/\" ) assert respx . calls . call_count == 1 respx . calls . assert_called_once () respx . reset () assert len ( respx . calls ) == 0 assert respx . calls . call_count == 0 respx . calls . assert_not_called ()","title":"Reset History"},{"location":"migrate/","text":"Migrate from requests responses Here's a few examples on how to migrate your code from the responses library to respx . Patching the Client Decorator @responses . activate def test_foo (): ... @respx . mock def test_foo (): ... See Router Settings for more details. Context Manager def test_foo (): with responses . RequestsMock () as rsps : ... def test_foo (): with respx . mock () as respx_mock : ... See Router Settings for more details. unittest setUp def setUp ( self ): self . responses = responses . RequestsMock () self . responses . start () self . addCleanup ( self . responses . stop ) def setUp ( self ): self . respx_mock = respx . mock () self . respx_mock . start () self . addCleanup ( self . respx_mock . stop ) See unittest examples for more details. Mock a Response responses . add ( responses . GET , \"https://example.org/\" , json = { \"foo\" : \"bar\" }, status = 200 , ) respx . get ( \"https://example.org/\" ) . respond ( 200 , json = { \"foo\" : \"bar\" }) See Routing Requests and Mocking Responses for more details. Mock an Exception responses . add ( responses . GET , \"https://example.org/\" , body = Exception ( \"...\" ), ) respx . get ( \"https://example.org/\" ) . mock ( side_effect = ConnectError ) See Exception Side Effect for more details. Subsequent Responses responses . add ( responses . GET , \"https://example.org/\" , status = 200 ) responses . add ( responses . GET , \"https://example.org/\" , status = 500 ) respx . get ( \"https://example.org/\" ) . mock ( side_effect = [ Response ( 200 ), Response ( 500 )] ) See Iterable Side Effect for more details. Callbacks def my_callback ( request ): headers = { \"Content-Type\" : \"application/json\" } body = { \"foo\" : \"bar\" } return ( 200 , headers , json . dumps ( resp_body )) responses . add_callback ( responses . GET , \"http://example.org/\" , callback = my_callback , ) def my_side_effect ( request , route ): return Response ( 200 , json = { \"foo\" : \"bar\" }) respx . get ( \"https://example.org/\" ) . mock ( side_effect = my_side_effect ) See Mock with a Side Effect for more details. History and Assertions History responses . calls [ 0 ] . request responses . calls [ 0 ] . response respx . calls [ 0 ] . request respx . calls [ 0 ] . response request , response = respx . calls [ 0 ] respx . calls . last . response See Call History for more details. Call Count responses . assert_call_count ( \"http://example.org/\" , 1 ) route = respx . get ( \"https://example.org/\" ) assert route . call_count == 1 See Call History for more details. All Called with responses . RequestsMock ( assert_all_requests_are_fired = False ) as rsps : ... with respx . mock ( assert_all_called = False ) as respx_mock : ... See Assert all Called for more details. Modify Mocked Response responses . add ( responses . GET , \"http://example.org/\" , json = { \"data\" : 1 }) responses . replace ( responses . GET , \"http://example.org/\" , json = { \"data\" : 2 }) respx . get ( \"https://example.org/\" ) . respond ( json = { \"data\" : 1 }) respx . get ( \"https://example.org/\" ) . respond ( json = { \"data\" : 2 }) Pass Through Requests responses . add_passthru ( \"https://example.org/\" ) respx . route ( url = \"https://example.org/\" ) . pass_through () See Pass Through for more details. requests-mock todo ... contribution welcome ;-)","title":"Migrate from requests"},{"location":"migrate/#migrate-from-requests","text":"","title":"Migrate from requests"},{"location":"migrate/#responses","text":"Here's a few examples on how to migrate your code from the responses library to respx .","title":"responses"},{"location":"migrate/#patching-the-client","text":"","title":"Patching the Client"},{"location":"migrate/#decorator","text":"@responses . activate def test_foo (): ... @respx . mock def test_foo (): ... See Router Settings for more details.","title":"Decorator"},{"location":"migrate/#context-manager","text":"def test_foo (): with responses . RequestsMock () as rsps : ... def test_foo (): with respx . mock () as respx_mock : ... See Router Settings for more details.","title":"Context Manager"},{"location":"migrate/#unittest-setup","text":"def setUp ( self ): self . responses = responses . RequestsMock () self . responses . start () self . addCleanup ( self . responses . stop ) def setUp ( self ): self . respx_mock = respx . mock () self . respx_mock . start () self . addCleanup ( self . respx_mock . stop ) See unittest examples for more details.","title":"unittest setUp"},{"location":"migrate/#mock-a-response","text":"responses . add ( responses . GET , \"https://example.org/\" , json = { \"foo\" : \"bar\" }, status = 200 , ) respx . get ( \"https://example.org/\" ) . respond ( 200 , json = { \"foo\" : \"bar\" }) See Routing Requests and Mocking Responses for more details.","title":"Mock a Response"},{"location":"migrate/#mock-an-exception","text":"responses . add ( responses . GET , \"https://example.org/\" , body = Exception ( \"...\" ), ) respx . get ( \"https://example.org/\" ) . mock ( side_effect = ConnectError ) See Exception Side Effect for more details.","title":"Mock an Exception"},{"location":"migrate/#subsequent-responses","text":"responses . add ( responses . GET , \"https://example.org/\" , status = 200 ) responses . add ( responses . GET , \"https://example.org/\" , status = 500 ) respx . get ( \"https://example.org/\" ) . mock ( side_effect = [ Response ( 200 ), Response ( 500 )] ) See Iterable Side Effect for more details.","title":"Subsequent Responses"},{"location":"migrate/#callbacks","text":"def my_callback ( request ): headers = { \"Content-Type\" : \"application/json\" } body = { \"foo\" : \"bar\" } return ( 200 , headers , json . dumps ( resp_body )) responses . add_callback ( responses . GET , \"http://example.org/\" , callback = my_callback , ) def my_side_effect ( request , route ): return Response ( 200 , json = { \"foo\" : \"bar\" }) respx . get ( \"https://example.org/\" ) . mock ( side_effect = my_side_effect ) See Mock with a Side Effect for more details.","title":"Callbacks"},{"location":"migrate/#history-and-assertions","text":"","title":"History and Assertions"},{"location":"migrate/#history","text":"responses . calls [ 0 ] . request responses . calls [ 0 ] . response respx . calls [ 0 ] . request respx . calls [ 0 ] . response request , response = respx . calls [ 0 ] respx . calls . last . response See Call History for more details.","title":"History"},{"location":"migrate/#call-count","text":"responses . assert_call_count ( \"http://example.org/\" , 1 ) route = respx . get ( \"https://example.org/\" ) assert route . call_count == 1 See Call History for more details.","title":"Call Count"},{"location":"migrate/#all-called","text":"with responses . RequestsMock ( assert_all_requests_are_fired = False ) as rsps : ... with respx . mock ( assert_all_called = False ) as respx_mock : ... See Assert all Called for more details.","title":"All Called"},{"location":"migrate/#modify-mocked-response","text":"responses . add ( responses . GET , \"http://example.org/\" , json = { \"data\" : 1 }) responses . replace ( responses . GET , \"http://example.org/\" , json = { \"data\" : 2 }) respx . get ( \"https://example.org/\" ) . respond ( json = { \"data\" : 1 }) respx . get ( \"https://example.org/\" ) . respond ( json = { \"data\" : 2 })","title":"Modify Mocked Response"},{"location":"migrate/#pass-through-requests","text":"responses . add_passthru ( \"https://example.org/\" ) respx . route ( url = \"https://example.org/\" ) . pass_through () See Pass Through for more details.","title":"Pass Through Requests"},{"location":"migrate/#requests-mock","text":"todo ... contribution welcome ;-)","title":"requests-mock"},{"location":"mocking/","text":"Mock HTTPX RESPX is a mock router, capturing requests sent by HTTPX , mocking their responses. Inspired by the flexible query API of the Django ORM, requests are filtered and matched against routes and their request patterns and lookups . Request patterns are bits of the request, like host method path etc, with given lookup values, combined using bitwise operators to form a Route , i.e. respx.route(path__regex=...) A captured request, matching a Route , resolves to a mocked httpx.Response , or triggers a given side effect . To skip mocking a specific request, a route can be marked to pass through . Read the User Guide for a complete walk-through.","title":"Mock HTTPX"},{"location":"mocking/#mock-httpx","text":"RESPX is a mock router, capturing requests sent by HTTPX , mocking their responses. Inspired by the flexible query API of the Django ORM, requests are filtered and matched against routes and their request patterns and lookups . Request patterns are bits of the request, like host method path etc, with given lookup values, combined using bitwise operators to form a Route , i.e. respx.route(path__regex=...) A captured request, matching a Route , resolves to a mocked httpx.Response , or triggers a given side effect . To skip mocking a specific request, a route can be marked to pass through . Read the User Guide for a complete walk-through.","title":"Mock HTTPX"},{"location":"upgrade/","text":"Upgrade Guide As of RESPX version 0.15.0 , the API has changed, but kept with deprecation warnings, later to be broken for backward compatibility in 0.16.0 . The biggest change involved separating request pattern arguments from response details. This brings the RESPX request matching API closer to the HTTPX client API, and the response mocking aligned with the python Mock API. Responses Response details are now mocked separatelty: # Previously respx . post ( \"https://some.url/\" , status_code = 200 , content = { \"x\" : 1 }) # Now respx . post ( \"https://some.url/\" ) . mock ( return_value = Response ( 200 , json = { \"x\" : 1 })) respx . post ( \"https://some.url/\" ) . respond ( 200 , json = { \"x\" : 1 }) respx . post ( \"https://some.url/\" ) % dict ( json = { \"x\" : 1 }) The .add API has changed to .route : # Previously respx . add ( \"POST\" , \"https://some.url/\" , content = \"foobar\" ) # Now respx . route ( method = \"POST\" , url = \"https://some.url/\" ) . respond ( content = \"foobar\" ) Callbacks Callbacks and simulated errors are now side effects : # Previously respx . post ( \"https://some.url/\" , content = callback ) respx . post ( \"https://some.url/\" , content = Exception ()) respx . add ( callback ) # Now respx . post ( \"https://some.url/\" ) . mock ( side_effect = callback ) respx . post ( \"https://some.url/\" ) . mock ( side_effect = Exception ) respx . route () . mock ( side_effect = callback ) Stacking Repeating a mocked response, for stacking, is now solved with side effects : # Previously respx . post ( \"https://some.url/\" , status_code = 404 ) respx . post ( \"https://some.url/\" , status_code = 200 ) # Now respx . post ( \"https://some.url/\" ) . mock ( side_effect = [ Response ( 404 ), Response ( 200 ), ], ) Note: Repeating a route in 0.15.0+ replaces any existing route with same pattern. Aliasing Aliases changed to named routes : # Previously respx . post ( \"https://example.org/\" , alias = \"example\" ) assert respx . aliases [ \"example\" ] . called # Now respx . post ( \"https://example.org/\" , name = \"example\" ) assert respx . routes [ \"example\" ] . called History Call history renamed : # Previously assert respx . stats . call_count == 1 # Now assert respx . calls . call_count == 1 MockTransport The respx.MockTransport should no longer be used as a mock router, use respx.mock(...) . # Previously my_mock = respx . MockTransport ( assert_all_called = False ) # Now my_mock = respx . mock ( assert_all_called = False )","title":"Upgrading"},{"location":"upgrade/#upgrade-guide","text":"As of RESPX version 0.15.0 , the API has changed, but kept with deprecation warnings, later to be broken for backward compatibility in 0.16.0 . The biggest change involved separating request pattern arguments from response details. This brings the RESPX request matching API closer to the HTTPX client API, and the response mocking aligned with the python Mock API.","title":"Upgrade Guide"},{"location":"upgrade/#responses","text":"Response details are now mocked separatelty: # Previously respx . post ( \"https://some.url/\" , status_code = 200 , content = { \"x\" : 1 }) # Now respx . post ( \"https://some.url/\" ) . mock ( return_value = Response ( 200 , json = { \"x\" : 1 })) respx . post ( \"https://some.url/\" ) . respond ( 200 , json = { \"x\" : 1 }) respx . post ( \"https://some.url/\" ) % dict ( json = { \"x\" : 1 }) The .add API has changed to .route : # Previously respx . add ( \"POST\" , \"https://some.url/\" , content = \"foobar\" ) # Now respx . route ( method = \"POST\" , url = \"https://some.url/\" ) . respond ( content = \"foobar\" )","title":"Responses"},{"location":"upgrade/#callbacks","text":"Callbacks and simulated errors are now side effects : # Previously respx . post ( \"https://some.url/\" , content = callback ) respx . post ( \"https://some.url/\" , content = Exception ()) respx . add ( callback ) # Now respx . post ( \"https://some.url/\" ) . mock ( side_effect = callback ) respx . post ( \"https://some.url/\" ) . mock ( side_effect = Exception ) respx . route () . mock ( side_effect = callback )","title":"Callbacks"},{"location":"upgrade/#stacking","text":"Repeating a mocked response, for stacking, is now solved with side effects : # Previously respx . post ( \"https://some.url/\" , status_code = 404 ) respx . post ( \"https://some.url/\" , status_code = 200 ) # Now respx . post ( \"https://some.url/\" ) . mock ( side_effect = [ Response ( 404 ), Response ( 200 ), ], ) Note: Repeating a route in 0.15.0+ replaces any existing route with same pattern.","title":"Stacking"},{"location":"upgrade/#aliasing","text":"Aliases changed to named routes : # Previously respx . post ( \"https://example.org/\" , alias = \"example\" ) assert respx . aliases [ \"example\" ] . called # Now respx . post ( \"https://example.org/\" , name = \"example\" ) assert respx . routes [ \"example\" ] . called","title":"Aliasing"},{"location":"upgrade/#history","text":"Call history renamed : # Previously assert respx . stats . call_count == 1 # Now assert respx . calls . call_count == 1","title":"History"},{"location":"upgrade/#mocktransport","text":"The respx.MockTransport should no longer be used as a mock router, use respx.mock(...) . # Previously my_mock = respx . MockTransport ( assert_all_called = False ) # Now my_mock = respx . mock ( assert_all_called = False )","title":"MockTransport"},{"location":"versions/0.14.0/api/","text":"Warning This is the documentation of the older version 0.14.0 . See latest for current release. Developer Interface - Version 0.14.0 Mocking Responses HTTP Method API For regular and simple use, use the HTTP method shorthands. See Request API for parameters. respx. get ( url=None , * , name=None , **lookups ) respx. options (...) respx. head (...) respx. post (...) respx. put (...) respx. patch (...) respx. delete (...) Request API For full control, use the core add method. respx. add ( route , * , name=None ) Parameters: method - str | callable | RequestPattern Request HTTP method, or Request callback , to match. url - (optional) str | pattern | tuple (httpcore) | httpx.URL Request exact URL, or URL pattern , to match. params - (optional) str | list | dict Request URL params to merge with url. status_code - (optional) int - default: 200 Response status code to mock. headers - (optional) dict Response headers to mock. content_type - (optional) str Response Content-Type header value to mock. content - (optional) bytes | str | list | dict | callable | exception - default b\"\" Response content to mock. - See Response Content . text - (optional) str Response text content to mock, with automatic content type header. html - (optional) str Response html content to mock, with automatic content type header. json - (optional) str | list | dict Response json content to mock, with automatic content type header. pass_through - (optional) bool - default False Mark matched request to pass-through to real server, e.g. don't mock . alias - (optional) str Name this request pattern. - See Call Statistics . Matching Requests Exact URL To match and mock a request by an exact URL, pass the url parameter as a string . respx . get ( \"https://foo.bar/\" , status_code = 204 ) URL pattern Instead of matching an exact URL , you can pass a compiled regex to match the request URL. import httpx import re import respx @respx . mock def test_something (): url_pattern = re . compile ( r \"^https://foo.bar/\\w+/$\" ) respx . get ( url_pattern , content = \"Baz\" ) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . text == \"Baz\" Tip Named groups in the regex pattern will be passed as kwargs to the response content callback , if used. Base URL When adding a lot of request patterns sharing the same domain/prefix, you can configure RESPX with a base_url to use as the base when matching URLs. Like url , the base_url can also be passed as a compiled regex , with optional named groups. import httpx import respx @respx . mock ( base_url = \"https://foo.bar\" ) async def test_something ( respx_mock ): async with httpx . AsyncClient ( base_url = \"https://foo.bar\" ) as client : request = respx_mock . get ( \"/baz/\" , content = \"Baz\" ) response = await client . get ( \"/baz/\" ) assert response . text == \"Baz\" Request callback For full control of what request to match and what response to mock , pass a callback function as the add(method, ...) parameter. The callback's response argument will be pre-populated with any additional response parameters. import httpx import respx def match_and_mock ( request , response ): \"\"\" Return `None` to not match the request. Return the `response` to match and mock this request. Return the `request` for pass-through behaviour. \"\"\" if request . method != \"POST\" : return None if \"X-Auth-Token\" not in request . headers : response . status_code = 401 else : response . content = \"OK\" return response @respx . mock def test_something (): custom_request = respx . add ( match_and_mock , status_code = 201 ) respx . get ( \"https://foo.bar/baz/\" ) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . status_code == 200 assert not custom_request . called response = httpx . post ( \"https://foo.bar/baz/\" ) assert response . status_code == 401 assert custom_request . called response = httpx . post ( \"https://foo.bar/baz/\" , headers = { \"X-Auth-Token\" : \"x\" }) assert response . status_code == 201 assert custom_request . call_count == 2 Repeated patterns If you mock several responses with the same request pattern , they will be matched in order, and popped til the last one. import httpx import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/baz/123/\" , status_code = 404 ) respx . get ( \"https://foo.bar/baz/123/\" , content = { \"id\" : 123 }) respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . status_code == 404 # First match response = httpx . post ( \"https://foo.bar/baz/\" ) assert response . status_code == 201 response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . status_code == 200 # Second match assert response . json () == { \"id\" : 123 } Manipulating Existing Patterns Clearing all existing patterns: import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/baz\" , status_code = 404 ) respx . clear () # no patterns will be matched after this call Removing and optionally re-using an existing pattern by alias: import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/\" , status_code = 404 , alias = \"index\" ) request_pattern = respx . pop ( \"index\" ) respx . get ( request_pattern . url , status_code = 200 ) Response Content JSON content To mock a response with json content, pass a list or a dict . The Content-Type header will automatically be set to application/json . import httpx import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/baz/123/\" , content = { \"id\" : 123 }) response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . json () == { \"id\" : 123 } Content callback If you need dynamic response content, pass a callback function. When used together with a URL pattern , named groups will be passed as kwargs . import httpx import re import respx def some_content ( request , slug = None ): \"\"\" Return bytes, str, list or a dict. \"\"\" return { \"slug\" : slug } @respx . mock def test_something (): url_pattern = r \"^https://foo.bar/(?P<slug>\\w+)/$\" ) respx . get ( url_pattern , content = some_content ) response = httpx . get ( \"https://foo.bar/apa/\" ) assert response . json () == { \"slug\" : \"apa\" } Request Error To simulate a failing request, like a connection error , pass an Exception instance. This is useful when you need to test proper HTTPX error handling in your app. import httpx import httpcore import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/\" , content = httpcore . ConnectTimeout ()) response = httpx . get ( \"https://foo.bar/\" ) # Will raise Built-in Assertions RESPX has the following built-in assertion checks: assert_all_mocked Asserts that all captured HTTPX requests are mocked. Defaults to True . assert_all_called Asserts that all mocked request patterns were called. Defaults to True . Configure checks by using the respx.mock decorator / context manager with parentheses. @respx . mock ( assert_all_called = False ) def test_something ( respx_mock ): respx_mock . get ( \"https://some.url/\" ) # OK respx_mock . get ( \"https://foo.bar/\" ) response = httpx . get ( \"https://foo.bar/\" ) assert response . status_code == 200 assert respx_mock . calls . call_count == 1 with respx . mock ( assert_all_mocked = False ) as respx_mock : response = httpx . get ( \"https://foo.bar/\" ) # OK assert response . status_code == 200 assert respx_mock . calls . call_count == 1 Without Parentheses When using the global scope @respx.mock decorator / context manager, assert_all_called is disabled . Call History The respx API includes a .calls object, containing captured ( request , response ) named tuples and MagicMock's bells and whistles , i.e. call_count , assert_called etc. Retrieving mocked calls A matched and mocked Call can be retrieved from call history, by either unpacking... request , response = respx . calls . last request , response = respx . calls [ - 2 ] # by call order ...or by accessing request or response directly... last_response = respx . calls . last . response assert respx . calls . last . request . call_count == 1 assert respx . calls . last . response . status_code == 200 Deprecation Warning As of version 0.14.0 , statistics via respx.stats is deprecated, in favour of respx.calls . Request Pattern calls Each mocked response request pattern has its own .calls , along with .called and .call_count stats shortcuts. Example using locally added request pattern: import httpx import respx @respx . mock def test_something (): request = respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) httpx . post ( \"https://foo.bar/baz/\" ) assert request . called assert request . call_count == 1 assert request . calls . last . response . status_code == 201 request . calls . assert_called_once () Example using globally aliased request pattern: import httpx import respx # Added somewhere outside the test respx . get ( \"https://foo.bar/\" , alias = \"index\" ) @respx . mock def test_something (): httpx . get ( \"https://foo.bar/\" ) assert respx . aliases [ \"index\" ] . called assert respx . aliases [ \"index\" ] . call_count == 1 last_index_response = respx . aliases [ \"index\" ] . calls . last . response Reset stats To reset stats during a test case, without stop mocking , use respx.reset() . import httpx import respx @respx . mock def test_something (): respx . post ( \"https://foo.bar/baz/\" ) httpx . post ( \"https://foo.bar/baz/\" ) assert respx . calls . call_count == 1 request . calls . assert_called_once () respx . reset () assert len ( respx . calls ) == 0 assert respx . calls . call_count == 0 respx . calls . assert_not_called () Examples Here's a handful example usages of the call stats API. import httpx import respx @respx . mock def test_something (): # Mock some calls respx . get ( \"https://foo.bar/\" , alias = \"index\" ) baz_request = respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) # Make some calls httpx . get ( \"https://foo.bar/\" ) httpx . post ( \"https://foo.bar/baz/\" ) # Assert mocked assert respx . aliases [ \"index\" ] . called assert respx . aliases [ \"index\" ] . call_count == 1 assert baz_request . called assert baz_request . call_count == 1 baz_request . calls . assert_called_once () # Global stats increased assert respx . calls . call_count == 2 # Assert responses assert respx . aliases [ \"index\" ] . calls . last . response . status_code == 200 assert respx . calls . last . response is baz_request . calls . last . response assert respx . calls . last . response . status_code == 201 # Reset respx . reset () assert len ( respx . calls ) == 0 assert respx . calls . call_count == 0 respx . calls . assert_not_called ()","title":"Developer Interface"},{"location":"versions/0.14.0/api/#developer-interface-version-0140","text":"","title":"Developer Interface - Version 0.14.0"},{"location":"versions/0.14.0/api/#mocking-responses","text":"","title":"Mocking Responses"},{"location":"versions/0.14.0/api/#http-method-api","text":"For regular and simple use, use the HTTP method shorthands. See Request API for parameters. respx. get ( url=None , * , name=None , **lookups ) respx. options (...) respx. head (...) respx. post (...) respx. put (...) respx. patch (...) respx. delete (...)","title":"HTTP Method API"},{"location":"versions/0.14.0/api/#request-api","text":"For full control, use the core add method. respx. add ( route , * , name=None ) Parameters: method - str | callable | RequestPattern Request HTTP method, or Request callback , to match. url - (optional) str | pattern | tuple (httpcore) | httpx.URL Request exact URL, or URL pattern , to match. params - (optional) str | list | dict Request URL params to merge with url. status_code - (optional) int - default: 200 Response status code to mock. headers - (optional) dict Response headers to mock. content_type - (optional) str Response Content-Type header value to mock. content - (optional) bytes | str | list | dict | callable | exception - default b\"\" Response content to mock. - See Response Content . text - (optional) str Response text content to mock, with automatic content type header. html - (optional) str Response html content to mock, with automatic content type header. json - (optional) str | list | dict Response json content to mock, with automatic content type header. pass_through - (optional) bool - default False Mark matched request to pass-through to real server, e.g. don't mock . alias - (optional) str Name this request pattern. - See Call Statistics .","title":"Request API"},{"location":"versions/0.14.0/api/#matching-requests","text":"","title":"Matching Requests"},{"location":"versions/0.14.0/api/#exact-url","text":"To match and mock a request by an exact URL, pass the url parameter as a string . respx . get ( \"https://foo.bar/\" , status_code = 204 )","title":"Exact URL"},{"location":"versions/0.14.0/api/#url-pattern","text":"Instead of matching an exact URL , you can pass a compiled regex to match the request URL. import httpx import re import respx @respx . mock def test_something (): url_pattern = re . compile ( r \"^https://foo.bar/\\w+/$\" ) respx . get ( url_pattern , content = \"Baz\" ) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . text == \"Baz\" Tip Named groups in the regex pattern will be passed as kwargs to the response content callback , if used.","title":"URL pattern"},{"location":"versions/0.14.0/api/#base-url","text":"When adding a lot of request patterns sharing the same domain/prefix, you can configure RESPX with a base_url to use as the base when matching URLs. Like url , the base_url can also be passed as a compiled regex , with optional named groups. import httpx import respx @respx . mock ( base_url = \"https://foo.bar\" ) async def test_something ( respx_mock ): async with httpx . AsyncClient ( base_url = \"https://foo.bar\" ) as client : request = respx_mock . get ( \"/baz/\" , content = \"Baz\" ) response = await client . get ( \"/baz/\" ) assert response . text == \"Baz\"","title":"Base URL"},{"location":"versions/0.14.0/api/#request-callback","text":"For full control of what request to match and what response to mock , pass a callback function as the add(method, ...) parameter. The callback's response argument will be pre-populated with any additional response parameters. import httpx import respx def match_and_mock ( request , response ): \"\"\" Return `None` to not match the request. Return the `response` to match and mock this request. Return the `request` for pass-through behaviour. \"\"\" if request . method != \"POST\" : return None if \"X-Auth-Token\" not in request . headers : response . status_code = 401 else : response . content = \"OK\" return response @respx . mock def test_something (): custom_request = respx . add ( match_and_mock , status_code = 201 ) respx . get ( \"https://foo.bar/baz/\" ) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . status_code == 200 assert not custom_request . called response = httpx . post ( \"https://foo.bar/baz/\" ) assert response . status_code == 401 assert custom_request . called response = httpx . post ( \"https://foo.bar/baz/\" , headers = { \"X-Auth-Token\" : \"x\" }) assert response . status_code == 201 assert custom_request . call_count == 2","title":"Request callback"},{"location":"versions/0.14.0/api/#repeated-patterns","text":"If you mock several responses with the same request pattern , they will be matched in order, and popped til the last one. import httpx import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/baz/123/\" , status_code = 404 ) respx . get ( \"https://foo.bar/baz/123/\" , content = { \"id\" : 123 }) respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . status_code == 404 # First match response = httpx . post ( \"https://foo.bar/baz/\" ) assert response . status_code == 201 response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . status_code == 200 # Second match assert response . json () == { \"id\" : 123 }","title":"Repeated patterns"},{"location":"versions/0.14.0/api/#manipulating-existing-patterns","text":"Clearing all existing patterns: import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/baz\" , status_code = 404 ) respx . clear () # no patterns will be matched after this call Removing and optionally re-using an existing pattern by alias: import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/\" , status_code = 404 , alias = \"index\" ) request_pattern = respx . pop ( \"index\" ) respx . get ( request_pattern . url , status_code = 200 )","title":"Manipulating Existing Patterns"},{"location":"versions/0.14.0/api/#response-content","text":"","title":"Response Content"},{"location":"versions/0.14.0/api/#json-content","text":"To mock a response with json content, pass a list or a dict . The Content-Type header will automatically be set to application/json . import httpx import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/baz/123/\" , content = { \"id\" : 123 }) response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . json () == { \"id\" : 123 }","title":"JSON content"},{"location":"versions/0.14.0/api/#content-callback","text":"If you need dynamic response content, pass a callback function. When used together with a URL pattern , named groups will be passed as kwargs . import httpx import re import respx def some_content ( request , slug = None ): \"\"\" Return bytes, str, list or a dict. \"\"\" return { \"slug\" : slug } @respx . mock def test_something (): url_pattern = r \"^https://foo.bar/(?P<slug>\\w+)/$\" ) respx . get ( url_pattern , content = some_content ) response = httpx . get ( \"https://foo.bar/apa/\" ) assert response . json () == { \"slug\" : \"apa\" }","title":"Content callback"},{"location":"versions/0.14.0/api/#request-error","text":"To simulate a failing request, like a connection error , pass an Exception instance. This is useful when you need to test proper HTTPX error handling in your app. import httpx import httpcore import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/\" , content = httpcore . ConnectTimeout ()) response = httpx . get ( \"https://foo.bar/\" ) # Will raise","title":"Request Error"},{"location":"versions/0.14.0/api/#built-in-assertions","text":"RESPX has the following built-in assertion checks: assert_all_mocked Asserts that all captured HTTPX requests are mocked. Defaults to True . assert_all_called Asserts that all mocked request patterns were called. Defaults to True . Configure checks by using the respx.mock decorator / context manager with parentheses. @respx . mock ( assert_all_called = False ) def test_something ( respx_mock ): respx_mock . get ( \"https://some.url/\" ) # OK respx_mock . get ( \"https://foo.bar/\" ) response = httpx . get ( \"https://foo.bar/\" ) assert response . status_code == 200 assert respx_mock . calls . call_count == 1 with respx . mock ( assert_all_mocked = False ) as respx_mock : response = httpx . get ( \"https://foo.bar/\" ) # OK assert response . status_code == 200 assert respx_mock . calls . call_count == 1 Without Parentheses When using the global scope @respx.mock decorator / context manager, assert_all_called is disabled .","title":"Built-in Assertions"},{"location":"versions/0.14.0/api/#call-history","text":"The respx API includes a .calls object, containing captured ( request , response ) named tuples and MagicMock's bells and whistles , i.e. call_count , assert_called etc.","title":"Call History"},{"location":"versions/0.14.0/api/#retrieving-mocked-calls","text":"A matched and mocked Call can be retrieved from call history, by either unpacking... request , response = respx . calls . last request , response = respx . calls [ - 2 ] # by call order ...or by accessing request or response directly... last_response = respx . calls . last . response assert respx . calls . last . request . call_count == 1 assert respx . calls . last . response . status_code == 200 Deprecation Warning As of version 0.14.0 , statistics via respx.stats is deprecated, in favour of respx.calls .","title":"Retrieving mocked calls"},{"location":"versions/0.14.0/api/#request-pattern-calls","text":"Each mocked response request pattern has its own .calls , along with .called and .call_count stats shortcuts. Example using locally added request pattern: import httpx import respx @respx . mock def test_something (): request = respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) httpx . post ( \"https://foo.bar/baz/\" ) assert request . called assert request . call_count == 1 assert request . calls . last . response . status_code == 201 request . calls . assert_called_once () Example using globally aliased request pattern: import httpx import respx # Added somewhere outside the test respx . get ( \"https://foo.bar/\" , alias = \"index\" ) @respx . mock def test_something (): httpx . get ( \"https://foo.bar/\" ) assert respx . aliases [ \"index\" ] . called assert respx . aliases [ \"index\" ] . call_count == 1 last_index_response = respx . aliases [ \"index\" ] . calls . last . response","title":"Request Pattern calls"},{"location":"versions/0.14.0/api/#reset-stats","text":"To reset stats during a test case, without stop mocking , use respx.reset() . import httpx import respx @respx . mock def test_something (): respx . post ( \"https://foo.bar/baz/\" ) httpx . post ( \"https://foo.bar/baz/\" ) assert respx . calls . call_count == 1 request . calls . assert_called_once () respx . reset () assert len ( respx . calls ) == 0 assert respx . calls . call_count == 0 respx . calls . assert_not_called ()","title":"Reset stats"},{"location":"versions/0.14.0/api/#examples","text":"Here's a handful example usages of the call stats API. import httpx import respx @respx . mock def test_something (): # Mock some calls respx . get ( \"https://foo.bar/\" , alias = \"index\" ) baz_request = respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) # Make some calls httpx . get ( \"https://foo.bar/\" ) httpx . post ( \"https://foo.bar/baz/\" ) # Assert mocked assert respx . aliases [ \"index\" ] . called assert respx . aliases [ \"index\" ] . call_count == 1 assert baz_request . called assert baz_request . call_count == 1 baz_request . calls . assert_called_once () # Global stats increased assert respx . calls . call_count == 2 # Assert responses assert respx . aliases [ \"index\" ] . calls . last . response . status_code == 200 assert respx . calls . last . response is baz_request . calls . last . response assert respx . calls . last . response . status_code == 201 # Reset respx . reset () assert len ( respx . calls ) == 0 assert respx . calls . call_count == 0 respx . calls . assert_not_called ()","title":"Examples"},{"location":"versions/0.14.0/mocking/","text":"Warning This is the documentation of the older version 0.14.0 . See latest for current release. Mock HTTPX - Version 0.14.0 To mock out HTTPX and/or HTTP Core , use the respx.mock decorator / context manager. Optionally configure built-in assertion checks and base URL with respx.mock(...) . Using the Decorator import httpx import respx @respx . mock def test_something (): request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" Using the Context Manager import httpx import respx with respx . mock : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" NOTE You can also start and stop mocking HTTPX manually, by calling respx.start() and respx.stop() . Using the mock Transports The built-in transports are the base of all mocking and patching in RESPX. In fact , respx.mock is an actual instance of MockTransport . MockTransport import httpx import respx mock_transport = respx . MockTransport () request = mock_transport . get ( \"https://foo.bar/\" , content = \"foobar\" ) with mock_transport : response = httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" SyncMockTransport If you don't need to patch the original HTTPX / HTTP Core transports, then use the SyncMockTransport or AsyncMockTransport directly, by passing the transport arg when instantiating your HTTPX client, or alike. import httpx import respx mock_transport = respx . SyncMockTransport () request = mock_transport . get ( \"https://foo.bar/\" , content = \"foobar\" ) with httpx . Client ( transport = mock_transport ) as client : response = client . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" AsyncMockTransport import httpx import respx mock_transport = respx . AsyncMockTransport () request = mock_transport . get ( \"https://foo.bar/\" , content = \"foobar\" ) async with httpx . AsyncClient ( transport = mock_transport ) as client : response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" NOTE The mock transports takes the same configuration arguments as the decorator / context manager. Global Setup & Teardown pytest # conftest.py import pytest import respx @pytest . fixture def mocked_api (): with respx . mock ( base_url = \"https://foo.bar\" ) as respx_mock : respx_mock . get ( \"/users/\" , content = [], alias = \"list_users\" ) ... yield respx_mock # test_api.py import httpx def test_list_users ( mocked_api ): response = httpx . get ( \"https://foo.bar/users/\" ) request = mocked_api [ \"list_users\" ] assert request . called assert response . json () == [] Tip Use a session scoped fixture @pytest.fixture(scope=\"session\") when your fixture contains multiple endpoints that not necessary gets called by a single test case, or disable the built-in assert_all_called check. unittest # testcases.py class MockedAPIMixin : def setUp ( self ): self . mocked_api = respx . mock ( base_url = \"https://foo.bar\" ) self . mocked_api . get ( \"/users/\" , content = [], alias = \"list_users\" ) ... self . mocked_api . start () def tearDown ( self ): self . mocked_api . stop () # test_api.py import unittest import httpx from .testcases import MockedAPIMixin class MyTestCase ( MockedAPIMixin , unittest . TestCase ): def test_list_users ( self ): response = httpx . get ( \"https://foo.bar/users/\" ) request = self . mocked_api [ \"list_users\" ] assert request . called assert response . json () == [] Tip Use setUpClass and tearDownClass when you mock multiple endpoints that not necessary gets called by a single test method, or disable the built-in assert_all_called check. Async Support You can use respx.mock in both sync and async contexts to mock out HTTPX responses. pytest @respx . mock @pytest . mark . asyncio async def test_something (): async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . text == \"foobar\" @pytest . mark . asyncio async def test_something (): async with respx . mock : async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . text == \"foobar\" Session Scoped Fixtures If a session scoped RESPX fixture is used in an async context, you also need to broaden the pytest-asyncio event_loop fixture. You can use the session_event_loop utility for this. # conftest.py import pytest import respx from respx.fixtures import session_event_loop as event_loop # noqa: F401 @pytest . fixture ( scope = \"session\" ) async def mocked_api ( event_loop ): # noqa: F811 async with respx . mock ( base_url = \"https://foo.bar\" ) as respx_mock : ... yield respx_mock unittest import asynctest class MyTestCase ( asynctest . TestCase ): @respx . mock async def test_something ( self ): async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . text == \"foobar\" async def test_something ( self ): async with respx . mock : async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . text == \"foobar\"","title":"Mock HTTPX"},{"location":"versions/0.14.0/mocking/#mock-httpx-version-0140","text":"To mock out HTTPX and/or HTTP Core , use the respx.mock decorator / context manager. Optionally configure built-in assertion checks and base URL with respx.mock(...) .","title":"Mock HTTPX - Version 0.14.0"},{"location":"versions/0.14.0/mocking/#using-the-decorator","text":"import httpx import respx @respx . mock def test_something (): request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\"","title":"Using the Decorator"},{"location":"versions/0.14.0/mocking/#using-the-context-manager","text":"import httpx import respx with respx . mock : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" NOTE You can also start and stop mocking HTTPX manually, by calling respx.start() and respx.stop() .","title":"Using the Context Manager"},{"location":"versions/0.14.0/mocking/#using-the-mock-transports","text":"The built-in transports are the base of all mocking and patching in RESPX. In fact , respx.mock is an actual instance of MockTransport .","title":"Using the mock Transports"},{"location":"versions/0.14.0/mocking/#mocktransport","text":"import httpx import respx mock_transport = respx . MockTransport () request = mock_transport . get ( \"https://foo.bar/\" , content = \"foobar\" ) with mock_transport : response = httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\"","title":"MockTransport"},{"location":"versions/0.14.0/mocking/#syncmocktransport","text":"If you don't need to patch the original HTTPX / HTTP Core transports, then use the SyncMockTransport or AsyncMockTransport directly, by passing the transport arg when instantiating your HTTPX client, or alike. import httpx import respx mock_transport = respx . SyncMockTransport () request = mock_transport . get ( \"https://foo.bar/\" , content = \"foobar\" ) with httpx . Client ( transport = mock_transport ) as client : response = client . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\"","title":"SyncMockTransport"},{"location":"versions/0.14.0/mocking/#asyncmocktransport","text":"import httpx import respx mock_transport = respx . AsyncMockTransport () request = mock_transport . get ( \"https://foo.bar/\" , content = \"foobar\" ) async with httpx . AsyncClient ( transport = mock_transport ) as client : response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" NOTE The mock transports takes the same configuration arguments as the decorator / context manager.","title":"AsyncMockTransport"},{"location":"versions/0.14.0/mocking/#global-setup-teardown","text":"","title":"Global Setup &amp; Teardown"},{"location":"versions/0.14.0/mocking/#pytest","text":"# conftest.py import pytest import respx @pytest . fixture def mocked_api (): with respx . mock ( base_url = \"https://foo.bar\" ) as respx_mock : respx_mock . get ( \"/users/\" , content = [], alias = \"list_users\" ) ... yield respx_mock # test_api.py import httpx def test_list_users ( mocked_api ): response = httpx . get ( \"https://foo.bar/users/\" ) request = mocked_api [ \"list_users\" ] assert request . called assert response . json () == [] Tip Use a session scoped fixture @pytest.fixture(scope=\"session\") when your fixture contains multiple endpoints that not necessary gets called by a single test case, or disable the built-in assert_all_called check.","title":"pytest"},{"location":"versions/0.14.0/mocking/#unittest","text":"# testcases.py class MockedAPIMixin : def setUp ( self ): self . mocked_api = respx . mock ( base_url = \"https://foo.bar\" ) self . mocked_api . get ( \"/users/\" , content = [], alias = \"list_users\" ) ... self . mocked_api . start () def tearDown ( self ): self . mocked_api . stop () # test_api.py import unittest import httpx from .testcases import MockedAPIMixin class MyTestCase ( MockedAPIMixin , unittest . TestCase ): def test_list_users ( self ): response = httpx . get ( \"https://foo.bar/users/\" ) request = self . mocked_api [ \"list_users\" ] assert request . called assert response . json () == [] Tip Use setUpClass and tearDownClass when you mock multiple endpoints that not necessary gets called by a single test method, or disable the built-in assert_all_called check.","title":"unittest"},{"location":"versions/0.14.0/mocking/#async-support","text":"You can use respx.mock in both sync and async contexts to mock out HTTPX responses.","title":"Async Support"},{"location":"versions/0.14.0/mocking/#pytest_1","text":"@respx . mock @pytest . mark . asyncio async def test_something (): async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . text == \"foobar\" @pytest . mark . asyncio async def test_something (): async with respx . mock : async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . text == \"foobar\" Session Scoped Fixtures If a session scoped RESPX fixture is used in an async context, you also need to broaden the pytest-asyncio event_loop fixture. You can use the session_event_loop utility for this. # conftest.py import pytest import respx from respx.fixtures import session_event_loop as event_loop # noqa: F401 @pytest . fixture ( scope = \"session\" ) async def mocked_api ( event_loop ): # noqa: F811 async with respx . mock ( base_url = \"https://foo.bar\" ) as respx_mock : ... yield respx_mock","title":"pytest"},{"location":"versions/0.14.0/mocking/#unittest_1","text":"import asynctest class MyTestCase ( asynctest . TestCase ): @respx . mock async def test_something ( self ): async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . text == \"foobar\" async def test_something ( self ): async with respx . mock : async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) assert request . called assert response . text == \"foobar\"","title":"unittest"}]}